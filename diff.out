diff --git a/TODO.md b/TODO.md
index 122cacc..ac4fd2d 100644
--- a/TODO.md
+++ b/TODO.md
@@ -1,10 +1,82 @@
+# Agent Network
 - decide whether to use workflowsteps or single step agents.
 - fine tune which models to use for which tasks.
+- currently RAG is not used in the graph
+- agents shoul have access to RAG via tool for independent research (within
+  their scope)
+-
 
 # TUI
 - how to handle corrections after task triggered? like queued messages
 - how to handle interruptions after task has triggered? (agents, RAG and history must be stateless, until the very end of the execution?).
--
+- we need a full execution summary
+
+## HITL
+
+‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
+‚îÇ ‚ü≥ Execution: Maze Runner Game [2m 45s]                  [BLOCKED]     ‚îÇ
+‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
+‚îÇ ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó   ‚îÇ
+‚îÇ ‚ïë üö® APPROVAL REQUIRED                           [1/3] coding-1    ‚ïë   ‚îÇ
+‚îÇ ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£   ‚îÇ
+‚îÇ ‚ïë                                                                  ‚ïë   ‚îÇ
+‚îÇ ‚ïë write_file: src/game_engine.py (342 lines)                      ‚ïë   ‚îÇ
+‚îÇ ‚ïë Task: Coding-3e61 ‚Üí Code Implementation                          ‚ïë   ‚îÇ
+‚îÇ ‚ïë                                                                  ‚ïë   ‚îÇ
+‚îÇ ‚ïë Impact: NEW FILE ‚Ä¢ pygame, numpy, asyncio                        ‚ïë   ‚îÇ
+‚îÇ ‚ïë                                                                  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ import pygame                                              ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ import numpy as np                                         ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ from typing import List, Tuple                             ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ                                                            ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ class GameEngine:                                          ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ     def __init__(self, width=800, height=600):             ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ         pygame.init()                                      ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ         self.screen = pygame.display.set_mode(...)         ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ         self.clock = pygame.time.Clock()                   ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ         ...                                                ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îÇ                                              [342 lines] ‚Üì  ‚îÇ  ‚ïë   ‚îÇ
+‚îÇ ‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚ïë   ‚îÇ
+‚îÇ ‚ïë                                                                  ‚ïë   ‚îÇ
+‚îÇ ‚ïë Reasoning: "Main game engine with Pygame for rendering, game    ‚ïë   ‚îÇ
+‚îÇ ‚ïë            loop, and entity management."                         ‚ïë   ‚îÇ
+‚îÇ ‚ïë                                                                  ‚ïë   ‚îÇ
+‚îÇ ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£   ‚îÇ
+‚îÇ ‚ïë [A]pprove  [M]odify  [R]eject  [D]efer  [V]iew full  [?]Help   ‚ïë   ‚îÇ
+‚îÇ ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚îÇ
+‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
+
+## diff view
+‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
+‚îÇ ‚úèÔ∏è  Editing: src/game_engine.py                              [Modified]‚îÇ
+‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
+‚îÇ Agent Proposed (Original)        ‚îÇ  Your Changes (Modified)            ‚îÇ
+‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
+‚îÇ  1 import pygame                 ‚îÇ  1 import pygame                    ‚îÇ
+‚îÇ  2 import numpy as np            ‚îÇ  2 import numpy as np               ‚îÇ
+‚îÇ  3 from typing import List       ‚îÇ  3 from typing import List, Dict    ‚îÇ
+‚îÇ  4                               ‚îÇ  4 import logging                   ‚îÇ
+‚îÇ  5 class GameEngine:             ‚îÇ  5                                  ‚îÇ
+‚îÇ  6     def __init__(self,        ‚îÇ  6 logger = logging.getLogger()     ‚îÇ
+‚îÇ  7         width=800,            ‚îÇ  7                                  ‚îÇ
+‚îÇ  8         height=600):          ‚îÇ  8 class GameEngine:                ‚îÇ
+‚îÇ  9         pygame.init()         ‚îÇ  9     def __init__(self,           ‚îÇ
+‚îÇ 10         self.screen = ...     ‚îÇ 10         width=800,               ‚îÇ
+‚îÇ 11                               ‚îÇ 11         height=600,              ‚îÇ
+‚îÇ 12     def run(self):            ‚îÇ 12         debug=False):     [+]    ‚îÇ
+‚îÇ 13         while True:           ‚îÇ 13         pygame.init()            ‚îÇ
+‚îÇ 14             ...               ‚îÇ 14         self.debug = debug [+]   ‚îÇ
+‚îÇ                                  ‚îÇ 15         self.screen = ...        ‚îÇ
+‚îÇ                                  ‚îÇ 16                                  ‚îÇ
+‚îÇ                                  ‚îÇ 17     def run(self):               ‚îÇ
+‚îÇ                                  ‚îÇ 18         logger.info("Start") [+] ‚îÇ
+‚îÇ                                  ‚îÇ 19         while True:              ‚îÇ
+‚îÇ [Lines 1-14 of 342]              ‚îÇ [Lines 1-19 of 348]          ‚Üì‚Üë    ‚îÇ
+‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
+‚îÇ Changes: +6 lines, 3 modifications                                     ‚îÇ
+‚îÇ [Ctrl+S] Save & Approve  [Ctrl+R] Revert  [Esc] Cancel & Reject       ‚îÇ
+‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 
 
 # RAG
diff --git a/crates/acp-tui/src/application/mod.rs b/crates/acp-tui/src/application/mod.rs
index cf49bfa..905f443 100644
--- a/crates/acp-tui/src/application/mod.rs
+++ b/crates/acp-tui/src/application/mod.rs
@@ -21,9 +21,9 @@ use tuirealm::{
 };
 
 use crate::{
-    client::{AcpClient, EventSource, EventType, StatusEvent}, components::realm::{
-        event_tree::EventTreeRealmComponent, help::HelpRealmComponent, root::RootRealmComponent, status_line::ConnectionState, HitlQueueRealmComponent, HitlReviewRealmComponent, QueryInputRealmComponent, StatusLineRealmComponent
-    }, config::Config, log_state_change, message::{APIEvent, ComponentId,  StatusSeverity, UserEvent}, services::{ApiService, QueryExecutor, WebSocketManager}, time_operation, utils::{generate_client_id, EventLogger}
+    client::{AcpClient, EventSource, EventType, HitlDecision, HitlDecisionRequest, StatusEvent}, components::{realm::{
+        event_tree::EventTreeRealmComponent, help::HelpRealmComponent, root::RootRealmComponent, status_line::ConnectionState, QueryInputRealmComponent, StatusLineRealmComponent
+    }, HitlReviewRealmComponent}, config::Config, log_state_change, message::{APIEvent, ComponentId,  StatusSeverity, UserEvent}, services::{ApiService, QueryExecutor, WebSocketManager}, time_operation, utils::{generate_client_id, EventLogger}
 };
 
 /// Async channel wrapper that implements PollAsync for AppMsg
@@ -134,9 +134,6 @@ impl Application {
         app.mount(ComponentId::HitlReview, Box::new(HitlReviewRealmComponent::new()), vec![])
             .context("Failed to mount HitlReview component")?;
 
-        app.mount(ComponentId::HitlQueue, Box::new(HitlQueueRealmComponent::new()), vec![])
-            .context("Failed to mount HitlQueue component")?;
-
         app.mount(ComponentId::Help, Box::new(HelpRealmComponent::new()), vec![])
             .context("Failed to mount HelpRealmComponent component")?;
 
@@ -540,43 +537,6 @@ impl Application {
                     format!("Query failed: {}", error));
             }
 
-
-            // ============== HITL Events ==============
-            UserEvent::HitlRequestReceived(request) => {
-                info!(request_id = %request.request_id, "HITL request received");
-                model.add_hitl_request(request);
-                model.switch_to_hitl_layout();
-            }
-
-            UserEvent::HitlReviewOpen(request_id) => {
-                info!(request_id = %request_id, "Opening HITL review");
-                if let Some(request) = model.remove_hitl_request(&request_id) {
-                    model.current_hitl_request = Some(request);
-                    model.focused_component = crate::message::ComponentId::HitlReview;
-                } else {
-                    warn!(request_id = %request_id, "HITL request not found");
-                }
-            }
-
-            UserEvent::HitlReviewClose => {
-                info!("Closing HITL review");
-                model.current_hitl_request = None;
-                model.switch_to_normal_layout();
-            }
-
-
-            UserEvent::HitlDecisionSent(request_id) => {
-                info!(request_id = %request_id, "HITL decision sent successfully");
-                model.set_status_message(StatusSeverity::Info,
-                    format!("HITL decision sent for {}", request_id));
-            }
-
-            UserEvent::HitlDecisionFailed(request_id, error) => {
-                warn!(request_id = %request_id, error = %error, "HITL decision failed");
-                model.set_status_message(StatusSeverity::Error,
-                    format!("HITL decision failed for {}: {}", request_id, error));
-            }
-
             // ============== UI Navigation Events ==============
             UserEvent::FocusNext => {
                 debug!(from = ?model.focused_component, "Focus next component");
@@ -600,17 +560,6 @@ impl Application {
                 model.toggle_help();
             }
 
-            // ============== Layout Events ==============
-            UserEvent::LayoutNormal => {
-                info!("Switching to normal layout");
-                model.switch_to_normal_layout();
-            }
-
-            UserEvent::LayoutHitlReview => {
-                info!("Switching to HITL review layout");
-                model.switch_to_hitl_layout();
-            }
-
             // ============== Error Events ==============
             UserEvent::ErrorOccurred(error) => {
                 warn!(error = %error, "Error occurred");
@@ -622,39 +571,16 @@ impl Application {
                 model.set_status_message(severity, message);
             }
 
+            UserEvent::HitlDecisionSubmit{id, approved, modified_content, reasoning } =>{
+                let hitl_decision = if approved{
+                    HitlDecision::Approve
+                }else{
+                    HitlDecision::Reject
+                };
 
-            UserEvent::HitlDecisionMade(request_id, decision) => {
-                info!(request_id = %request_id, decision = ?decision, "HITL decision made");
-                model.current_hitl_request = None;
-                if model.hitl_requests.is_empty() {
-                    model.switch_to_normal_layout();
-                }
-                // Submit HITL decision to API
-                let request_id = request_id.clone();
-                let decision = decision.clone();
-                let api_service = self.api_service.clone();
-                let sender = self.sender.clone();
-
-                tokio::spawn(async move {
-                    match api_service.submit_hitl_decision(request_id.clone(), decision).await {
-                        Ok(_) => {
-                            let _ = sender.send(APIEvent::HitlDecisionSent(request_id));
-                        }
-                        Err(e) => {
-                            let _ = sender.send(APIEvent::HitlDecisionFailed(request_id, e.to_string()));
-                        }
-                    }
-                });
-            }
-            UserEvent::HitlSubmitDecision=>{
+                let request = HitlDecisionRequest{ decision: HitlDecision::Approve, modified_content, reason: reasoning, request_id: id};
                 todo!("implementHitlSubmitDecision")
             }
-            UserEvent::HitlCancelReview=>{
-                todo!("HitlCancelReview")
-            }
-            UserEvent::HitlOpenReview=>{
-                todo!("HitlOpenReview")
-            }
         }
 
         Ok(())
diff --git a/crates/acp-tui/src/application/state.rs b/crates/acp-tui/src/application/state.rs
index 561bfc4..918aebe 100644
--- a/crates/acp-tui/src/application/state.rs
+++ b/crates/acp-tui/src/application/state.rs
@@ -5,9 +5,8 @@ use tuirealm::{AttrValue, Attribute};
 use crate::{
     components::realm::status_line::ConnectionState,
     components::StatusMessage,
-    message::{ComponentId, StatusSeverity, LayoutMode},
+    message::{ComponentId, StatusSeverity},
     models::tree::TimelineTree,
-    client::types::HitlApprovalRequest,
 };
 
 /// Core application state following Elm's Model pattern
@@ -25,18 +24,9 @@ pub struct AppModel {
     /// Currently focused component
     pub focused_component: ComponentId,
 
-    /// Current layout mode
-    pub layout_mode: LayoutMode,
-
     /// Whether help overlay is visible
     pub show_help: bool,
 
-    /// HITL requests queue
-    pub hitl_requests: Vec<HitlApprovalRequest>,
-
-    /// Currently selected HITL request for review
-    pub current_hitl_request: Option<HitlApprovalRequest>,
-
     /// Last execution timestamp
     pub last_execution_time: Option<DateTime<Utc>>,
 }
@@ -50,10 +40,7 @@ impl AppModel {
             connection_state: ConnectionState::Disconnected,
             status_message: None,
             focused_component: ComponentId::QueryInput, // Start with input focused
-            layout_mode: LayoutMode::Normal,
             show_help: false,
-            hitl_requests: Vec::new(),
-            current_hitl_request: None,
             last_execution_time: None,
         }
     }
@@ -80,75 +67,18 @@ impl AppModel {
 
     /// Focus next component in tab order (context-aware)
     pub fn focus_next_component(&mut self) {
-        self.focused_component = match self.layout_mode {
-            LayoutMode::Normal => {
-                // Normal mode: only QueryInput and Timeline are focusable
-                match self.focused_component {
-                    ComponentId::QueryInput => ComponentId::Timeline,
-                    ComponentId::Timeline => ComponentId::QueryInput,
-                    // If somehow on a non-normal component, reset to QueryInput
-                    _ => ComponentId::QueryInput,
-                }
-            }
-            LayoutMode::HitlReview => {
-                // HITL mode: QueryInput, Timeline, HitlQueue, HitlReview
-                match self.focused_component {
-                    ComponentId::Timeline => ComponentId::HitlQueue,
-                    ComponentId::HitlQueue => {
-                        if self.current_hitl_request.is_some() {
-                            ComponentId::HitlReview
-                        } else {
-                            ComponentId::Timeline
-                        }
-                    }
-                    ComponentId::HitlReview => ComponentId::Timeline,
-                    _ => ComponentId::Timeline,
-                }
-            }
-        };
+        self.focus_previous_component()
     }
 
     /// Focus previous component in tab order (context-aware)
     pub fn focus_previous_component(&mut self) {
-        self.focused_component = match self.layout_mode {
-            LayoutMode::Normal => {
-                // Normal mode: only QueryInput and Timeline are focusable
-                match self.focused_component {
-                    ComponentId::QueryInput => ComponentId::Timeline,
-                    ComponentId::Timeline => ComponentId::QueryInput,
-                    // If somehow on a non-normal component, reset to QueryInput
-                    _ => ComponentId::QueryInput,
-                }
-            }
-            LayoutMode::HitlReview => {
-                // HITL mode: reverse order
-                match self.focused_component {
-                    ComponentId::Timeline => {
-                        if self.current_hitl_request.is_some() {
-                            ComponentId::HitlReview
-                        } else {
-                            ComponentId::HitlQueue
-                        }
-                    }
-                    ComponentId::HitlQueue => ComponentId::Timeline,
-                    ComponentId::HitlReview => ComponentId::HitlQueue,
-                    _ => ComponentId::Timeline,
-                }
+        self.focused_component =
+            match self.focused_component {
+                ComponentId::QueryInput => ComponentId::Timeline,
+                ComponentId::Timeline => ComponentId::QueryInput,
+                // If somehow on a non-normal component, reset to QueryInput
+                _ => ComponentId::QueryInput,
             }
-        };
-    }
-
-    /// Add HITL request to queue
-    pub fn add_hitl_request(&mut self, request: HitlApprovalRequest) {
-        self.hitl_requests.push(request);
-    }
-
-    /// Remove HITL request from queue
-    pub fn remove_hitl_request(&mut self, request_id: &str) -> Option<HitlApprovalRequest> {
-        self.hitl_requests
-            .iter()
-            .position(|r| r.request_id == request_id)
-            .map(|index| self.hitl_requests.remove(index))
     }
 
     /// Toggle help visibility
@@ -156,13 +86,4 @@ impl AppModel {
         self.show_help = !self.show_help;
     }
 
-    /// Switch to HITL review layout
-    pub fn switch_to_hitl_layout(&mut self) {
-        self.layout_mode = LayoutMode::HitlReview;
-    }
-
-    /// Switch to normal layout
-    pub fn switch_to_normal_layout(&mut self) {
-        self.layout_mode = LayoutMode::Normal;
-    }
 }
diff --git a/crates/acp-tui/src/application/view.rs b/crates/acp-tui/src/application/view.rs
index 38962f1..754f610 100644
--- a/crates/acp-tui/src/application/view.rs
+++ b/crates/acp-tui/src/application/view.rs
@@ -5,37 +5,17 @@ use tuirealm::Application;
 
 use crate::{
     application::AppModel,
-    message::{ComponentId, LayoutMode},
+    message::{ComponentId },
 };
 
-/// Render the complete application UI
-pub fn render(
-    model: &AppModel,
-    app: &mut Application<ComponentId, crate::message::UserEvent, crate::message::APIEvent>,
-    frame: &mut Frame,
-) {
-    let area = frame.area();
-
-    match model.layout_mode {
-        LayoutMode::Normal => render_normal_layout(model, app, frame, area),
-        LayoutMode::HitlReview => render_hitl_layout(model, app, frame, area),
-    }
-    if model.show_help {
-        app.view(&ComponentId::Help, frame, area);
-    }
-    // Render HITL review modal if active
-    if model.current_hitl_request.is_some() {
-        app.view(&ComponentId::HitlReview, frame, area);
-    }
-}
 
 /// Render normal layout: Timeline + QueryInput + StatusLine
-fn render_normal_layout(
+pub fn render(
     model: &AppModel,
     app: &mut Application<ComponentId, crate::message::UserEvent, crate::message::APIEvent>,
     frame: &mut Frame,
-    area: Rect,
 ) {
+    let area = frame.area();
     let chunks = Layout::default()
         .direction(Direction::Vertical)
         .constraints([
@@ -49,31 +29,3 @@ fn render_normal_layout(
     app.view(&ComponentId::QueryInput, frame, chunks[1]);
     app.view(&ComponentId::StatusLine, frame, chunks[2]);
 }
-
-/// Render HITL review layout: HitlQueue + Timeline (smaller) + StatusLine
-fn render_hitl_layout(
-    model: &AppModel,
-    app: &mut Application<ComponentId, crate::message::UserEvent, crate::message::APIEvent>,
-    frame: &mut Frame,
-    area: Rect,
-) {
-    let main_chunks = Layout::default()
-        .direction(Direction::Horizontal)
-        .constraints([
-            Constraint::Length(40),     // HITL Queue sidebar
-            Constraint::Min(20),        // Main area
-        ])
-        .split(area);
-
-    let main_area_chunks = Layout::default()
-        .direction(Direction::Vertical)
-        .constraints([
-            Constraint::Min(5),         // Timeline
-            Constraint::Length(1),      // Status line
-        ])
-        .split(main_chunks[1]);
-
-    app.view(&ComponentId::HitlQueue, frame, main_chunks[0]);
-    app.view(&ComponentId::Timeline, frame, main_area_chunks[0]);
-    app.view(&ComponentId::StatusLine, frame, main_area_chunks[1]);
-}
diff --git a/crates/acp-tui/src/components/mod.rs b/crates/acp-tui/src/components/mod.rs
index b31d743..9923516 100644
--- a/crates/acp-tui/src/components/mod.rs
+++ b/crates/acp-tui/src/components/mod.rs
@@ -7,7 +7,7 @@ pub mod realm;
 // Re-export all TUIRealm components
 pub use realm::{
     QueryInputRealmComponent, StatusLineRealmComponent,
-    HitlReviewRealmComponent, HitlQueueRealmComponent,
+    HitlReviewRealmComponent,
 };
 
 // Legacy types for compatibility
diff --git a/crates/acp-tui/src/components/realm/hitl_queue.rs b/crates/acp-tui/src/components/realm/hitl_queue.rs
deleted file mode 100644
index fc3f6f3..0000000
--- a/crates/acp-tui/src/components/realm/hitl_queue.rs
+++ /dev/null
@@ -1,301 +0,0 @@
-//! HitlQueue TUIRealm component
-//!
-//! Displays a list of pending HITL approval requests.
-
-use ratatui::{
-    layout::Rect,
-    style::{Color, Modifier, Style},
-    text::{Line, Span},
-    widgets::{Block, Borders, List, ListItem, ListState},
-    Frame,
-};
-use tuirealm::{
-    command::{Cmd, CmdResult, Direction as MoveDirection},
-    event::{Key, KeyEvent as TuiKeyEvent},
-    Component, Event, MockComponent, State, StateValue, AttrValue, Attribute,
-};
-
-use crate::client::types::HitlApprovalRequest;
-use crate::message::{APIEvent, NoUserEvent, UserEvent};
-
-/// HitlQueue component using TUIRealm architecture
-pub struct HitlQueueRealmComponent {
-    /// List of pending HITL requests
-    requests: Vec<HitlApprovalRequest>,
-    /// List state for navigation
-    list_state: ListState,
-    /// Whether this component is focused
-    focused: bool,
-    /// Whether the queue is visible
-    visible: bool,
-}
-
-impl HitlQueueRealmComponent {
-    /// Create new HITL queue component
-    pub fn new() -> Self {
-        let mut list_state = ListState::default();
-        list_state.select(Some(0));
-
-        Self {
-            requests: Vec::new(),
-            list_state,
-            focused: false,
-            visible: false,
-        }
-    }
-
-    /// Add a new HITL request to the queue
-    pub fn add_request(&mut self, request: HitlApprovalRequest) {
-        self.requests.push(request);
-
-        // If this is the first request and nothing is selected, select it
-        if self.requests.len() == 1 {
-            self.list_state.select(Some(0));
-        }
-
-        // Show the queue if we have requests
-        if !self.requests.is_empty() {
-            self.visible = true;
-        }
-    }
-
-    /// Remove a request by ID
-    pub fn remove_request(&mut self, request_id: &str) -> Option<HitlApprovalRequest> {
-        if let Some(index) = self.requests.iter().position(|r| r.agent_id == request_id) {
-            let removed = self.requests.remove(index);
-
-            // Adjust selection if necessary
-            if let Some(selected) = self.list_state.selected() {
-                if selected >= self.requests.len() && !self.requests.is_empty() {
-                    self.list_state.select(Some(self.requests.len() - 1));
-                } else if self.requests.is_empty() {
-                    self.list_state.select(None);
-                    self.visible = false;
-                }
-            }
-
-            Some(removed)
-        } else {
-            None
-        }
-    }
-
-    /// Get the currently selected request
-    pub fn get_selected_request(&self) -> Option<&HitlApprovalRequest> {
-        self.list_state.selected()
-            .and_then(|index| self.requests.get(index))
-    }
-
-    /// Get the number of pending requests
-    pub fn request_count(&self) -> usize {
-        self.requests.len()
-    }
-
-    /// Move selection up
-    pub fn select_previous(&mut self) {
-        if self.requests.is_empty() {
-            return;
-        }
-
-        let selected = self.list_state.selected().unwrap_or(0);
-        let new_selected = if selected == 0 {
-            self.requests.len() - 1
-        } else {
-            selected - 1
-        };
-        self.list_state.select(Some(new_selected));
-    }
-
-    /// Move selection down
-    pub fn select_next(&mut self) {
-        if self.requests.is_empty() {
-            return;
-        }
-
-        let selected = self.list_state.selected().unwrap_or(0);
-        let new_selected = if selected >= self.requests.len() - 1 {
-            0
-        } else {
-            selected + 1
-        };
-        self.list_state.select(Some(new_selected));
-    }
-
-    /// Show the queue
-    pub fn show(&mut self) {
-        if !self.requests.is_empty() {
-            self.visible = true;
-        }
-    }
-
-    /// Hide the queue
-    pub fn hide(&mut self) {
-        self.visible = false;
-    }
-
-    /// Is the queue visible?
-    pub fn is_visible(&self) -> bool {
-        self.visible && !self.requests.is_empty()
-    }
-
-    /// Format a request for display (static version to avoid borrowing issues)
-    fn format_request_static(request: &HitlApprovalRequest, index: usize, selected: bool) -> ListItem {
-        // Use available fields from HitlApprovalRequest
-        let prefix = if selected { "‚ñ∂ " } else { "  " };
-        let agent_info = format!("{:?} Agent", request.agent_type);
-        let context_desc = if request.context.len() > 40 {
-            format!("{}...", &request.context[..37])
-        } else {
-            request.context.clone()
-        };
-
-        let line = Line::from(vec![
-            Span::raw(prefix),
-            Span::styled(format!("#{} ", index + 1), Style::default().fg(Color::Gray)),
-            Span::styled(
-                format!("[{}] ", agent_info),
-                Style::default().fg(Color::Blue).add_modifier(Modifier::BOLD)
-            ),
-            Span::raw(context_desc),
-        ]);
-
-        let style = if selected {
-            Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
-        } else {
-            Style::default()
-        };
-
-        ListItem::new(line).style(style)
-    }
-}
-
-impl Component<UserEvent, APIEvent> for HitlQueueRealmComponent {
-    fn on(&mut self, ev: Event<APIEvent>) -> Option<UserEvent> {
-        if !self.visible || !self.focused {
-            return None;
-        }
-
-        match ev {
-            Event::Keyboard(key_event) => {
-                match key_event {
-                    TuiKeyEvent { code: Key::Up, .. } => {
-                        self.select_previous();
-                        None
-                    },
-                    TuiKeyEvent { code: Key::Down, .. } => {
-                        self.select_next();
-                        None
-                    },
-                    TuiKeyEvent { code: Key::Enter, .. } => {
-                        // Open selected request for review
-                        if let Some(_request) = self.get_selected_request() {
-                            Some(UserEvent::HitlOpenReview)
-                        } else {
-                            None
-                        }
-                    },
-                    TuiKeyEvent { code: Key::Esc, .. } | TuiKeyEvent { code: Key::Char('q'), .. } => {
-                        self.hide();
-                        None
-                    },
-                    _ => None,
-                }
-            },
-            _ => None,
-        }
-    }
-}
-
-impl MockComponent for HitlQueueRealmComponent {
-    fn view(&mut self, frame: &mut Frame, area: Rect) {
-        if !self.is_visible() {
-            return;
-        }
-
-        let border_style = if self.focused {
-            Style::default().fg(Color::Yellow)
-        } else {
-            Style::default().fg(Color::White)
-        };
-
-        let title = format!(" HITL Queue ({}) ", self.requests.len());
-
-        // Create list items - avoid borrowing self
-        let selected_index = self.list_state.selected();
-        let mut items = Vec::new();
-        for (index, request) in self.requests.iter().enumerate() {
-            let selected = selected_index == Some(index);
-            items.push(Self::format_request_static(request, index, selected));
-        }
-
-        let list = List::new(items)
-            .block(Block::default()
-                .title(title)
-                .borders(Borders::ALL)
-                .border_style(border_style))
-            .highlight_style(
-                Style::default()
-                    .fg(Color::Yellow)
-                    .add_modifier(Modifier::BOLD)
-            );
-
-        frame.render_stateful_widget(list, area, &mut self.list_state);
-    }
-
-    fn query(&self, attr: Attribute) -> Option<AttrValue> {
-        match attr {
-            Attribute::Focus => Some(AttrValue::Flag(self.focused)),
-            Attribute::Display => Some(AttrValue::Flag(self.visible)),
-            _ => None,
-        }
-    }
-
-    fn attr(&mut self, attr: Attribute, value: AttrValue) {
-        match attr {
-            Attribute::Focus => {
-                if let AttrValue::Flag(focused) = value {
-                    self.focused = focused;
-                }
-            }
-            Attribute::Display => {
-                if let AttrValue::Flag(visible) = value {
-                    if visible {
-                        self.show();
-                    } else {
-                        self.hide();
-                    }
-                }
-            }
-            _ => {}
-        }
-    }
-
-    fn state(&self) -> State {
-        if let Some(selected) = self.list_state.selected() {
-            State::One(StateValue::Usize(selected))
-        } else {
-            State::None
-        }
-    }
-
-    fn perform(&mut self, cmd: Cmd) -> CmdResult {
-        match cmd {
-            Cmd::Move(MoveDirection::Up) => {
-                self.select_previous();
-                CmdResult::Changed(self.state())
-            },
-            Cmd::Move(MoveDirection::Down) => {
-                self.select_next();
-                CmdResult::Changed(self.state())
-            },
-            Cmd::Submit => {
-                if let Some(request) = self.get_selected_request() {
-                    CmdResult::Submit(State::One(StateValue::String(request.request_id.clone())))
-                } else {
-                    CmdResult::None
-                }
-            },
-            _ => CmdResult::None,
-        }
-    }
-}
diff --git a/crates/acp-tui/src/components/realm/hitl_review.rs b/crates/acp-tui/src/components/realm/hitl_review.rs
index 3729176..cbc8769 100644
--- a/crates/acp-tui/src/components/realm/hitl_review.rs
+++ b/crates/acp-tui/src/components/realm/hitl_review.rs
@@ -1,244 +1,749 @@
-//! HitlReview TUIRealm component
+//! HITL Review Modal Component
 //!
-//! Modal component for reviewing HITL approval requests.
+//! Displays a modal overlay for human-in-the-loop approval requests.
+//! Blocks user interaction with other components until a decision is made.
 
-use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
 use ratatui::{
-    Frame,
-    layout::{Constraint, Direction, Layout, Rect},
-    style::{Color, Style},
+    layout::{Alignment, Constraint, Direction, Layout, Rect},
+    style::{Color, Modifier, Style},
     text::{Line, Span},
     widgets::{Block, Borders, Clear, Paragraph, Wrap},
+    Frame,
 };
+use tui_textarea::{Input, TextArea};
+use tui_textarea::Key as TextAreaKey;
 use tuirealm::{
     command::{Cmd, CmdResult},
-    event::{Key, KeyEvent as TuiKeyEvent},
-    Component, Event, MockComponent, State, StateValue, AttrValue, Attribute,
+    event::{Key, KeyEvent as TuiKeyEvent, KeyModifiers},
+    props::{Alignment as PropsAlignment, AttrValue, Attribute, BorderType, Borders as PropBorders},
+    Component, Event, MockComponent, State,
 };
-use tui_textarea::TextArea;
+use tracing::{debug, info, warn};
 
-use crate::client::types::{HitlApprovalRequest, HitlDecisionRequest, HitlDecision as ApiHitlDecision};
-use crate::message::{APIEvent, NoUserEvent, UserEvent};
+use crate::{client::{EventType, StatusEvent}, message::{APIEvent, UserEvent}};
 
-/// Review modes for the HITL window
+/// Input mode for the modal
 #[derive(Debug, Clone, PartialEq)]
-pub enum ReviewMode {
-    /// Viewing the request details
-    Viewing,
-    /// Editing modification content
-    Editing,
-    /// Confirming decision
-    Confirming,
+enum InputMode {
+    /// Normal mode - keyboard shortcuts active
+    Normal,
+    /// Editing reasoning text
+    EditingReasoning,
 }
-
-/// Local HITL decision type for UI logic
+/// Risk level for HITL requests
 #[derive(Debug, Clone, PartialEq)]
-pub enum HitlDecision {
-    Approve,
-    Reject,
-    Modify,
+pub enum RiskLevel {
+    High,    // write_file, bash_command, delete
+    Medium,  // install, network calls
+    Low,     // read_file, search
+}
+
+impl RiskLevel {
+    pub fn from_string(s: &str) -> Self {
+        match s.to_lowercase().as_str() {
+            "high" => Self::High,
+            "medium" => Self::Medium,
+            "low" => Self::Low,
+            _ => Self::Medium, // Default to medium if unknown
+        }
+    }
+
+    pub fn color(&self) -> Color {
+        match self {
+            Self::High => Color::Red,
+            Self::Medium => Color::Yellow,
+            Self::Low => Color::Blue,
+        }
+    }
+
+    pub fn icon(&self) -> &'static str {
+        match self {
+            Self::High => "üö®",
+            Self::Medium => "‚ö†Ô∏è ",
+            Self::Low => "‚ÑπÔ∏è ",
+        }
+    }
 }
 
-/// HitlReview component using TUIRealm architecture
+/// HITL request data
+#[derive(Debug, Clone)]
+pub struct HitlRequest {
+    pub id: String,
+    pub tool_name: String,
+    pub description: String,
+    pub risk_level: RiskLevel,
+    pub preview: String,
+    pub reasoning: Option<String>,
+    pub metadata: HitlMetadata,
+}
+
+/// Metadata about the HITL request
+#[derive(Debug, Clone)]
+pub struct HitlMetadata {
+    pub file_path: Option<String>,
+    pub file_size: Option<usize>,
+    pub is_new_file: bool,
+    pub dependencies: Vec<String>,
+    pub command: Option<String>,
+}
+
+/// HITL Review Modal Component
 pub struct HitlReviewRealmComponent {
-    /// Current HITL request being reviewed
-    current_request: Option<HitlApprovalRequest>,
-    /// Text area for review comments/modifications
-    textarea: TextArea<'static>,
-    /// Current review mode
-    mode: ReviewMode,
-    /// User's decision
-    decision: Option<HitlDecision>,
-    /// Whether the review window is visible
+    /// Current HITL request being displayed
+    current_request: Option<HitlRequest>,
+
+    /// Queue of pending requests
+    request_queue: Vec<HitlRequest>,
+
+    /// Current scroll position in preview
+    scroll_offset: usize,
+
+    /// Whether the modal is visible
     visible: bool,
-    /// Whether this component is focused
-    focused: bool,
+
+    /// Auto-approve timer (seconds remaining for low-risk)
+    auto_approve_timer: Option<u32>,
+
+    /// Whether timer is paused
+    timer_paused: bool,
+
+    /// Current input mode
+    input_mode: InputMode,
+
+    /// Textarea for reasoning input
+    reasoning_textarea: TextArea<'static>,
+
+    /// Pending decision (approval/rejection waiting for reasoning)
+    pending_decision: Option<bool>, // Some(true) = approve, Some(false) = reject, None = no pending
 }
 
 impl HitlReviewRealmComponent {
-    /// Create new HITL review component
     pub fn new() -> Self {
-        let mut textarea = TextArea::default();
-        textarea.set_block(
+        let mut reasoning_textarea = TextArea::default();
+        reasoning_textarea.set_placeholder_text("Enter your reasoning (optional)...");
+        reasoning_textarea.set_block(
             Block::default()
-                .title(" Review Comments / Modifications ")
                 .borders(Borders::ALL)
-                .style(Style::default().fg(Color::Yellow))
+                .title("Reasoning")
+                .border_style(Style::default().fg(Color::White)),
         );
-        textarea.set_style(Style::default().fg(Color::White));
-        textarea.set_placeholder_text("Enter your comments or modifications here...");
 
         Self {
             current_request: None,
-            textarea,
-            mode: ReviewMode::Viewing,
-            decision: None,
+            request_queue: Vec::new(),
+            scroll_offset: 0,
             visible: false,
-            focused: false,
+            auto_approve_timer: None,
+            timer_paused: false,
+            input_mode: InputMode::Normal,
+            reasoning_textarea,
+            pending_decision: None,
         }
     }
 
-    /// Show review window with a request
-    pub fn show_review(&mut self, request: HitlApprovalRequest) {
-        self.current_request = Some(request);
-        self.mode = ReviewMode::Viewing;
-        self.decision = None;
-        self.textarea = TextArea::default();
-        self.textarea.set_placeholder_text("Enter your comments or modifications here...");
-        self.visible = true;
-        self.focused = true;
+     /// Start editing reasoning
+    fn start_reasoning_input(&mut self, approved: bool) {
+        self.pending_decision = Some(approved);
+        self.input_mode = InputMode::EditingReasoning;
+        self.reasoning_textarea.set_block(
+            Block::default()
+                .borders(Borders::ALL)
+                .title("Reasoning (Ctrl+S to submit, Esc to cancel)")
+                .border_style(Style::default().fg(Color::Yellow)),
+        );
     }
 
-    /// Hide the review window
-    pub fn hide(&mut self) {
-        self.visible = false;
-        self.focused = false;
-        self.current_request = None;
-        self.decision = None;
-        self.mode = ReviewMode::Viewing;
+    /// Cancel reasoning input and return to normal mode
+    fn cancel_reasoning_input(&mut self) {
+        self.pending_decision = None;
+        self.input_mode = InputMode::Normal;
+        self.reasoning_textarea = TextArea::default();
+        self.reasoning_textarea.set_placeholder_text("Enter your reasoning (optional)...");
+        self.reasoning_textarea.set_block(
+            Block::default()
+                .borders(Borders::ALL)
+                .title("Reasoning")
+                .border_style(Style::default().fg(Color::White)),
+        );
     }
 
-    /// Set decision
-    pub fn set_decision(&mut self, decision: HitlDecision) {
-        if decision == HitlDecision::Modify {
-            self.mode = ReviewMode::Editing;
-        } else {
-            self.mode = ReviewMode::Confirming;
+    /// Submit decision with reasoning
+    fn submit_with_reasoning(&mut self) -> Option<UserEvent> {
+        if let Some(approved) = self.pending_decision {
+            let reasoning_text = self.reasoning_textarea.lines().join("\n");
+            let reasoning = if reasoning_text.trim().is_empty() {
+                None
+            } else {
+                Some(reasoning_text)
+            };
+
+            info!(
+                "HITL decision: {} with reasoning: {:?}",
+                if approved { "approved" } else { "rejected" },
+                reasoning
+            );
+
+            if let Some(request) = &self.current_request {
+                let event = UserEvent::HitlDecisionSubmit {
+                    id: request.id.clone(),
+                    approved,
+                    modified_content: None,
+                    reasoning
+                };
+
+                // Clear textarea and return to normal mode
+                self.cancel_reasoning_input();
+
+                // Move to next request
+                self.next_request();
+
+                return Some(event);
+            }
         }
-        self.decision = Some(decision);
+        None
     }
 
-    /// Submit the current decision
-    pub fn submit_decision(&mut self) -> Option<APIEvent> {
-        if let (Some(ref request), Some(decision)) = (&self.current_request, &self.decision) {
-            let reason = if self.textarea.lines().iter().any(|line| !line.is_empty()) {
-                Some(self.textarea.lines().join("\n"))
-            } else {
-                None
+    /// Handle approval decision (prompts for reasoning)
+    fn approve(&mut self) -> Option<UserEvent> {
+        self.start_reasoning_input(true);
+        None // Don't emit event yet, wait for reasoning
+    }
+
+    /// Handle rejection decision (prompts for reasoning)
+    fn reject(&mut self) -> Option<UserEvent> {
+        self.start_reasoning_input(false);
+        None // Don't emit event yet, wait for reasoning
+    }
+
+    /// Quick approve without reasoning (Shift+A)
+    fn quick_approve(&mut self) -> Option<UserEvent> {
+        if let Some(request) = &self.current_request {
+            info!("HITL quick approved (no reasoning): {}", request.tool_name);
+
+            let event = UserEvent::HitlDecisionSubmit {
+                id: request.id.clone(),
+                approved: true,
+                modified_content: None,
+                reasoning: None
             };
 
-            // Clone the data we need before calling self.hide()
-            let request_agent_id = request.agent_id.clone();
-            let decision_clone = decision.clone();
+            self.next_request();
+            Some(event)
+        } else {
+            None
+        }
+    }
+
+    /// Quick reject without reasoning (Shift+R)
+    fn quick_reject(&mut self) -> Option<UserEvent> {
+        if let Some(request) = &self.current_request {
+            info!("HITL quick rejected (no reasoning): {}", request.tool_name);
 
-            // Create the decision request before calling hide()
-            let decision_request = HitlDecisionRequest {
-                decision: self.convert_to_api_decision(&decision_clone),
-                modified_content: reason.clone(),
-                request_id: request_agent_id.clone(),
-                reason,
+            let event = UserEvent::HitlDecisionSubmit {
+                id: request.id.clone(),
+                approved: false,
+                modified_content: None,
+                reasoning: None,
             };
 
-            // Now we can call hide() since we've extracted all the data we need
-            self.hide();
+            self.next_request();
+            Some(event)
+        } else {
+            None
+        }
+    }
+
+    /// Add a new HITL request to the queue
+    pub fn push_request(&mut self, request: HitlRequest) {
+        info!(
+            "HITL request queued: {} by {}",
+            request.tool_name, request.id
+        );
+
+        // If no current request, show immediately
+        if self.current_request.is_none() {
+            self.show_request(request);
+        } else {
+            self.request_queue.push(request);
+        }
+    }
+
+    /// Show a request in the modal
+    fn show_request(&mut self, request: HitlRequest) {
+        // Set auto-approve timer for low-risk operations
+        self.auto_approve_timer = if request.risk_level == RiskLevel::Low {
+            Some(10) // 10 seconds
+        } else {
+            None
+        };
+
+        self.current_request = Some(request);
+        self.visible = true;
+        self.scroll_offset = 0;
+        self.timer_paused = false;
+    }
+
+    /// Move to next request in queue
+    fn next_request(&mut self) -> Option<UserEvent> {
+        if let Some(next) = self.request_queue.pop() {
+            self.show_request(next);
+            None
+        } else {
+            // No more requests, hide modal
+            self.current_request = None;
+            self.visible = false;
+            None
+        }
+    }
+
+    /// Handle defer decision
+    fn defer(&mut self) -> Option<UserEvent> {
+        if let Some(request) = self.current_request.take() {
+            info!("HITL deferred: {}", request.tool_name);
+
+            // Put at end of queue
+            self.request_queue.push(request);
 
-            Some(APIEvent::HitlDecisionMade(
-                request_agent_id,
-                decision_request
-            ))
+            // Move to next
+            self.next_request()
         } else {
             None
         }
     }
 
-    /// Is the component visible?
+    /// Scroll preview up
+    fn scroll_up(&mut self) {
+        self.scroll_offset = self.scroll_offset.saturating_sub(1);
+    }
+
+    /// Scroll preview down
+    fn scroll_down(&mut self) {
+        self.scroll_offset = self.scroll_offset.saturating_add(1);
+    }
+
+    /// Tick for auto-approve timer
+    pub fn tick(&mut self) -> Option<UserEvent> {
+        if self.timer_paused {
+            return None;
+        }
+
+        if let Some(timer) = self.auto_approve_timer.as_mut() {
+            if *timer > 0 {
+                *timer -= 1;
+            } else {
+                // Timer expired, auto-approve
+                info!("Auto-approving low-risk HITL request");
+                return self.approve();
+            }
+        }
+        None
+    }
+
+    /// Toggle timer pause
+    fn toggle_timer(&mut self) {
+        self.timer_paused = !self.timer_paused;
+    }
+
+    /// Get current queue position
+    fn queue_position(&self) -> String {
+        let total = self.request_queue.len() + 1; // +1 for current
+        format!("[1/{}]", total)
+    }
+
+    /// Check if modal should be visible
     pub fn is_visible(&self) -> bool {
         self.visible
     }
 
-    /// Convert UI HitlDecision to API HitlDecision
-    fn convert_to_api_decision(&self, decision: &HitlDecision) -> ApiHitlDecision {
-        match decision {
-            HitlDecision::Approve => ApiHitlDecision::Approve,
-            HitlDecision::Reject => ApiHitlDecision::Reject,
-            HitlDecision::Modify => ApiHitlDecision::Modify,
+    /// Render the modal content
+    fn render_modal(&mut self, frame: &mut Frame, area: Rect) {
+        if let Some(request) = &self.current_request {
+            // Center the modal (85% width, 80% height)
+            let modal_area = centered_rect(85, 80, area);
+
+            // Clear background
+            frame.render_widget(Clear, modal_area);
+
+            // Split into header, body, reasoning, footer
+            let chunks = Layout::default()
+                .direction(Direction::Vertical)
+                .constraints([
+                    Constraint::Length(3),   // Header
+                    Constraint::Min(8),      // Body (preview)
+                    Constraint::Length(5),   // Reasoning textarea
+                    Constraint::Length(3),   // Footer
+                ])
+                .split(modal_area);
+
+            // Render header
+            self.render_header(frame, chunks[0], request);
+
+            // Render body
+            self.render_body(frame, chunks[1], request);
+
+            // Render reasoning textarea
+            frame.render_widget(&self.reasoning_textarea, chunks[2]);
+
+            // Render footer
+            self.render_footer(frame, chunks[3], request);
         }
     }
 
-    /// Get the popup area for centering the modal
-    fn get_popup_area(&self, area: Rect) -> Rect {
-        let popup_width = area.width.min(80);
-        let popup_height = area.height.min(30);
+    fn render_header(&self, frame: &mut Frame, area: Rect, request: &HitlRequest) {
+        let risk_color = request.risk_level.color();
+        let risk_icon = request.risk_level.icon();
+
+        let title = format!(
+            "{} {}                    {}    {}",
+            risk_icon,
+            request.tool_name,
+            request.id,
+            self.queue_position()
+        );
+
+        let header = Paragraph::new(title)
+            .style(Style::default().fg(risk_color).add_modifier(Modifier::BOLD))
+            .alignment(Alignment::Left)
+            .block(
+                Block::default()
+                    .borders(Borders::ALL)
+                    .border_style(Style::default().fg(risk_color))
+                    .border_type(ratatui::widgets::BorderType::Double),
+            );
+
+        frame.render_widget(header, area);
+    }
+
+    fn render_body(&self, frame: &mut Frame, area: Rect, request: &HitlRequest) {
+        let mut lines = Vec::new();
+
+        // File/command info
+        if let Some(ref path) = request.metadata.file_path {
+            let size_info = if let Some(size) = request.metadata.file_size {
+                format!(" ({} lines{})", size, if request.metadata.is_new_file { ", NEW" } else { "" })
+            } else {
+                String::new()
+            };
+
+            lines.push(Line::from(vec![
+                Span::styled("File: ", Style::default().add_modifier(Modifier::BOLD)),
+                Span::raw(format!("{}{}", path, size_info)),
+            ]));
+        }
+
+        if let Some(ref cmd) = request.metadata.command {
+            lines.push(Line::from(vec![
+                Span::styled("$ ", Style::default().fg(Color::Green)),
+                Span::raw(cmd),
+            ]));
+        }
+
+        // Dependencies
+        if !request.metadata.dependencies.is_empty() {
+            lines.push(Line::from(vec![
+                Span::styled("Deps: ", Style::default().add_modifier(Modifier::BOLD)),
+                Span::raw(request.metadata.dependencies.join(", ")),
+            ]));
+        }
+
+        lines.push(Line::from("")); // Blank line
 
-        Rect {
-            x: (area.width.saturating_sub(popup_width)) / 2,
-            y: (area.height.saturating_sub(popup_height)) / 2,
-            width: popup_width,
-            height: popup_height,
+        // Preview box
+        lines.push(Line::from("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"));
+
+        let preview_lines: Vec<&str> = request.preview.lines().collect();
+        let visible_lines = 10; // Max lines to show
+        for (_i, line) in preview_lines.iter()
+            .skip(self.scroll_offset)
+            .take(visible_lines)
+            .enumerate()
+        {
+            let truncated = if line.len() > 58 {
+                format!("{}...", &line[..55])
+            } else {
+                format!("{:<58}", line)
+            };
+            lines.push(Line::from(format!("‚îÇ {} ‚îÇ", truncated)));
         }
+
+        // Scroll indicator
+        let scroll_indicator = if preview_lines.len() > visible_lines {
+            format!("[L{}/{:3}] ‚Üì‚Üë", self.scroll_offset + 1, preview_lines.len())
+        } else {
+            format!("[{} lines]", preview_lines.len())
+        };
+        lines.push(Line::from(format!("‚îÇ{:>60}‚îÇ", scroll_indicator)));
+        lines.push(Line::from("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"));
+
+        lines.push(Line::from("")); // Blank line
+
+        // Reasoning
+        if let Some(ref reasoning) = request.reasoning {
+            lines.push(Line::from(vec![
+                Span::styled("\"", Style::default().fg(Color::Gray)),
+                Span::styled(reasoning, Style::default().fg(Color::Gray).add_modifier(Modifier::ITALIC)),
+                Span::styled("\"", Style::default().fg(Color::Gray)),
+            ]));
+        }
+
+        // Auto-approve timer
+        if let Some(timer) = self.auto_approve_timer {
+            lines.push(Line::from(""));
+            let timer_text = if self.timer_paused {
+                format!("‚è∏  Auto-approve PAUSED (was {}s)", timer)
+            } else {
+                format!("‚è∞ Auto-approving in {}s...", timer)
+            };
+            lines.push(Line::from(Span::styled(
+                timer_text,
+                Style::default().fg(Color::Yellow),
+            )));
+        }
+
+        let body = Paragraph::new(lines)
+            .block(Block::default().borders(Borders::ALL))
+            .wrap(Wrap { trim: false });
+
+        frame.render_widget(body, area);
+    }
+
+    fn render_footer(&self, frame: &mut Frame, area: Rect, request: &HitlRequest) {
+        let actions = match self.input_mode {
+            InputMode::EditingReasoning => {
+                if self.pending_decision == Some(true) {
+                    "Approving with reason | Ctrl+S: Submit | Esc: Cancel"
+                } else {
+                    "Rejecting with reason | Ctrl+S: Submit | Esc: Cancel"
+                }
+            }
+            InputMode::Normal => {
+                if request.risk_level == RiskLevel::Low {
+                    "[A] Approve  [R] Reject  [Space] Pause  [‚Üì‚Üë] Scroll  [Shift+A/R] Quick"
+                } else {
+                    "[A] Approve  [R] Reject  [D] Defer  [‚Üì‚Üë] Scroll  [Shift+A/R] Quick"
+                }
+            }
+        };
+
+        let style = match self.input_mode {
+            InputMode::EditingReasoning => Style::default().fg(Color::Yellow),
+            InputMode::Normal => Style::default().fg(Color::White),
+        };
+
+        let footer = Paragraph::new(actions)
+            .style(style)
+            .alignment(Alignment::Center)
+            .block(Block::default().borders(Borders::ALL));
+
+        frame.render_widget(footer, area);
     }
 }
 
 impl Component<UserEvent, APIEvent> for HitlReviewRealmComponent {
     fn on(&mut self, ev: Event<APIEvent>) -> Option<UserEvent> {
-        if !self.visible || !self.focused {
+        // Only handle events when visible
+        if !self.visible {
             return None;
         }
 
         match ev {
-            Event::Keyboard(key_event) => {
-                match self.mode {
-                    ReviewMode::Editing => {
-                        // Handle text editing
-                        match key_event {
+            // Keyboard events - HANDLE BOTH MODES
+            Event::Keyboard(keyevent) if self.visible => {
+                match self.input_mode {
+                    InputMode::EditingReasoning => {
+                        // In reasoning mode, pass keys to textarea
+                        match keyevent {
+                            // Submit reasoning with Ctrl+S
+                            TuiKeyEvent {
+                                code: Key::Char('s'),
+                                modifiers: KeyModifiers::CONTROL,
+                            } => self.submit_with_reasoning(),
+
+                            // Cancel with Esc
                             TuiKeyEvent { code: Key::Esc, .. } => {
-                                self.mode = ReviewMode::Viewing;
+                                self.cancel_reasoning_input();
                                 None
-                            },
-                            key => {
-                                // Convert to crossterm KeyEvent
-                                let crossterm_modifiers = KeyModifiers::NONE; // For now, just use NONE
-                                let crossterm_event = match key.code {
-                                    Key::Char(c) => KeyEvent::new(KeyCode::Char(c), crossterm_modifiers),
-                                    Key::Backspace => KeyEvent::new(KeyCode::Backspace, crossterm_modifiers),
-                                    Key::Delete => KeyEvent::new(KeyCode::Delete, crossterm_modifiers),
-                                    Key::Enter => KeyEvent::new(KeyCode::Enter, crossterm_modifiers),
-                                    Key::Left => KeyEvent::new(KeyCode::Left, crossterm_modifiers),
-                                    Key::Right => KeyEvent::new(KeyCode::Right, crossterm_modifiers),
-                                    Key::Up => KeyEvent::new(KeyCode::Up, crossterm_modifiers),
-                                    Key::Down => KeyEvent::new(KeyCode::Down, crossterm_modifiers),
+                            }
+
+                            // Pass other keys to textarea
+                            _ => {
+                                // Convert tuirealm KeyEvent to tui_textarea Input
+                                let input = match keyevent.code {
+                                    Key::Char(c) => Input {
+                                        key: TextAreaKey::Char(c),
+                                        ctrl: keyevent.modifiers.contains(KeyModifiers::CONTROL),
+                                        alt: keyevent.modifiers.contains(KeyModifiers::ALT),
+                                        shift: keyevent.modifiers.contains(KeyModifiers::SHIFT),
+                                    },
+                                    Key::Backspace => Input {
+                                        key: TextAreaKey::Backspace,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
+                                    Key::Delete => Input {
+                                        key: TextAreaKey::Delete,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
+                                    Key::Enter => Input {
+                                        key: TextAreaKey::Enter,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
+                                    Key::Left => Input {
+                                        key: TextAreaKey::Left,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
+                                    Key::Right => Input {
+                                        key: TextAreaKey::Right,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
+                                    Key::Up => Input {
+                                        key: TextAreaKey::Up,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
+                                    Key::Down => Input {
+                                        key: TextAreaKey::Down,
+                                        ctrl: false,
+                                        alt: false,
+                                        shift: false,
+                                    },
                                     _ => return None,
                                 };
-                                self.textarea.input(crossterm_event);
+
+                                self.reasoning_textarea.input(input);
                                 None
                             }
                         }
-                    },
-                    ReviewMode::Viewing => {
-                        // Handle navigation keys
-                        match key_event {
-                            TuiKeyEvent { code: Key::Char('a'), .. } => {
-                                self.set_decision(HitlDecision::Approve);
-                                None
-                            },
-                            TuiKeyEvent { code: Key::Char('r'), .. } => {
-                                self.set_decision(HitlDecision::Reject);
+                    }
+
+                    InputMode::Normal => {
+                        // Normal mode shortcuts
+                        match keyevent {
+                            // Approve (prompts for reasoning)
+                            TuiKeyEvent { code: Key::Char('a'), modifiers }
+                                if !modifiers.contains(KeyModifiers::SHIFT) => {
+                                self.approve()
+                            }
+
+                            // Quick approve (no reasoning)
+                            TuiKeyEvent {
+                                code: Key::Char('A'),
+                                modifiers: KeyModifiers::SHIFT,
+                            } | TuiKeyEvent {
+                                code: Key::Char('a'),
+                                modifiers: KeyModifiers::SHIFT,
+                            } => {
+                                self.quick_approve()
+                            }
+
+                            // Reject (prompts for reasoning)
+                            TuiKeyEvent { code: Key::Char('r'), modifiers }
+                                if !modifiers.contains(KeyModifiers::SHIFT) => {
+                                self.reject()
+                            }
+
+                            // Quick reject (no reasoning)
+                            TuiKeyEvent {
+                                code: Key::Char('R'),
+                                modifiers: KeyModifiers::SHIFT,
+                            } | TuiKeyEvent {
+                                code: Key::Char('r'),
+                                modifiers: KeyModifiers::SHIFT,
+                            }  => {
+                                self.quick_reject()
+                            }
+
+                            TuiKeyEvent { code: Key::Char('d'), .. }
+                            | TuiKeyEvent { code: Key::Char('D'), .. } => self.defer(),
+
+                            TuiKeyEvent { code: Key::Char(' '), .. } => {
+                                self.toggle_timer();
                                 None
-                            },
-                            TuiKeyEvent { code: Key::Char('m'), .. } => {
-                                self.set_decision(HitlDecision::Modify);
+                            }
+
+                            TuiKeyEvent { code: Key::Up, .. } => {
+                                self.scroll_up();
                                 None
-                            },
-                            TuiKeyEvent { code: Key::Char('q'), .. } | TuiKeyEvent { code: Key::Esc, .. } => {
-                                self.hide();
+                            }
+
+                            TuiKeyEvent { code: Key::Down, .. } => {
+                                self.scroll_down();
                                 None
-                            },
-                            _ => None,
-                        }
-                    },
-                    ReviewMode::Confirming => {
-                        match key_event {
-                            TuiKeyEvent { code: Key::Char('y'), .. } | TuiKeyEvent { code: Key::Enter, .. } => {
-                                Some(UserEvent::HitlSubmitDecision)
-                            },
-                            TuiKeyEvent { code: Key::Char('n'), .. } | TuiKeyEvent { code: Key::Esc, .. } => {
-                                Some(UserEvent::HitlCancelReview)
-                            },
+                            }
+
+                            TuiKeyEvent { code: Key::Esc, .. } => self.quick_reject(),
+
                             _ => None,
                         }
                     }
                 }
+            }
+            Event::User(APIEvent::StatusEventReceived(StatusEvent{event: EventType::HitlRequested { task_description, risk_level }, execution_id, source, timestamp })) => {
+                debug!("HITL request received, opening modal");
+
+                // Parse task_description to extract structured data
+                // For now, create a basic request - you'll need to enhance this parsing
+                let request = HitlRequest {
+                    id: execution_id,  // TODO: Extract from task_description
+                    tool_name: "unknown".to_string(), // TODO: Extract from task_description
+                    description: task_description.clone(),
+                    risk_level: RiskLevel::from_string(&risk_level),
+                    preview: task_description.clone(), // TODO: Extract actual preview
+                    reasoning: None,
+                    metadata: HitlMetadata {
+                        file_path: None,
+                        file_size: None,
+                        is_new_file: false,
+                        dependencies: vec![],
+                        command: None,
+                    },
+                };
+
+                self.push_request(request);
+                None // Don't propagate, handled internally
             },
+
+                // Handle HITL completion - CLOSE MODAL
+            Event::User(APIEvent::StatusEventReceived(StatusEvent{event: EventType::HitlCompleted { approved, reason }, execution_id, source, timestamp })) => {
+                debug!(
+                    "HITL completion received: {} (reason: {:?})",
+                    if approved { "approved" } else { "rejected" },
+                    reason
+                );
+
+                if let Some(request) = &self.current_request {
+                    // Emit decision event with current request context
+                    let event = UserEvent::HitlDecisionSubmit {
+                        id: request.id.clone(),
+                        approved,
+                        modified_content: None,
+                        reasoning: request.reasoning.clone(),
+                    };
+
+                    // Move to next request or close modal
+                    self.next_request();
+
+                    Some(event)
+                } else {
+                    warn!("Received HitlCompleted but no current request");
+                    None
+                }
+            }
+            Event::Tick => {
+                // Handle auto-approve timer
+                self.tick()
+            }
+
             _ => None,
         }
     }
@@ -246,159 +751,58 @@ impl Component<UserEvent, APIEvent> for HitlReviewRealmComponent {
 
 impl MockComponent for HitlReviewRealmComponent {
     fn view(&mut self, frame: &mut Frame, area: Rect) {
-        if !self.visible {
-            return;
-        }
-
-        let popup_area = self.get_popup_area(area);
-
-        // Clear the background
-        frame.render_widget(Clear, popup_area);
-
-        // Split into sections
-        let chunks = Layout::default()
-            .direction(Direction::Vertical)
-            .constraints([
-                Constraint::Min(8),       // Request details
-                Constraint::Length(8),    // Text area (when editing)
-                Constraint::Length(3),    // Instructions
-            ])
-            .split(popup_area);
-
-        // Render request details
-        if let Some(ref request) = self.current_request {
-            let title = format!(" HITL Review - Agent {} ", request.agent_id);
-            let border_color = match self.mode {
-                ReviewMode::Viewing => Color::Yellow,
-                ReviewMode::Editing => Color::Green,
-                ReviewMode::Confirming => Color::Red,
-            };
-
-            let details_text = vec![
-                Line::from(""),
-                Line::from(vec![Span::styled("Agent:", Style::default().fg(Color::Green))]),
-                Line::from(format!("  {} ({:?})", request.agent_id, request.agent_type)),
-                Line::from(""),
-                Line::from(vec![Span::styled("Context:", Style::default().fg(Color::Magenta))]),
-                Line::from(format!("  {}", request.context)),
-                Line::from(""),
-                Line::from(vec![Span::styled("Proposed Action:", Style::default().fg(Color::Yellow))]),
-                Line::from(format!("  {:?}", request.proposed_action)),
-                Line::from(""),
-                Line::from(vec![Span::styled("Proposed Changes:", Style::default().fg(Color::Cyan))]),
-                Line::from(format!("  {} files", request.proposed_changes.len())),
-            ];
-
-            let details_widget = Paragraph::new(details_text)
-                .block(Block::default()
-                    .title(title)
-                    .borders(Borders::ALL)
-                    .border_style(Style::default().fg(border_color)))
-                .wrap(Wrap { trim: true });
-
-            frame.render_widget(details_widget, chunks[0]);
-        }
-
-        // Render text area when editing
-        if self.mode == ReviewMode::Editing {
-            frame.render_widget(&self.textarea, chunks[1]);
+        if self.visible {
+            self.render_modal(frame, area);
         }
-
-        // Render instructions
-        let instructions = match self.mode {
-            ReviewMode::Viewing => {
-                vec![
-                    Line::from(""),
-                    Line::from(vec![
-                        Span::styled("[a]", Style::default().fg(Color::Green)),
-                        Span::raw("pprove  "),
-                        Span::styled("[r]", Style::default().fg(Color::Red)),
-                        Span::raw("eject  "),
-                        Span::styled("[m]", Style::default().fg(Color::Yellow)),
-                        Span::raw("odify  "),
-                        Span::styled("[q]", Style::default().fg(Color::Gray)),
-                        Span::raw("uit"),
-                    ]),
-                ]
-            },
-            ReviewMode::Editing => {
-                vec![
-                    Line::from(""),
-                    Line::from(vec![
-                        Span::raw("Edit your modifications above. Press "),
-                        Span::styled("Esc", Style::default().fg(Color::Yellow)),
-                        Span::raw(" when done."),
-                    ]),
-                ]
-            },
-            ReviewMode::Confirming => {
-                vec![
-                    Line::from(""),
-                    Line::from(vec![
-                        Span::raw("Confirm decision? "),
-                        Span::styled("[y]", Style::default().fg(Color::Green)),
-                        Span::raw("es  "),
-                        Span::styled("[n]", Style::default().fg(Color::Red)),
-                        Span::raw("o"),
-                    ]),
-                ]
-            }
-        };
-
-        let instructions_widget = Paragraph::new(instructions)
-            .block(Block::default().borders(Borders::ALL));
-
-        frame.render_widget(instructions_widget, chunks[2]);
     }
 
     fn query(&self, attr: Attribute) -> Option<AttrValue> {
         match attr {
-            Attribute::Focus => Some(AttrValue::Flag(self.focused)),
-            Attribute::Display => Some(AttrValue::Flag(self.visible)),
+            Attribute::Custom("visible") => Some(AttrValue::Flag(self.visible)),
             _ => None,
         }
     }
 
     fn attr(&mut self, attr: Attribute, value: AttrValue) {
         match attr {
-            Attribute::Focus => {
-                if let AttrValue::Flag(focused) = value {
-                    self.focused = focused;
-                }
-            }
-            Attribute::Display => {
-                if let AttrValue::Flag(visible) = value {
-                    if !visible {
-                        self.hide();
-                    }
-                }
+            Attribute::Custom("hitl_request") => {
+                // Receive HITL request - this would need custom serialization
+                // For now, handled via push_request() method
             }
             _ => {}
         }
     }
 
     fn state(&self) -> State {
-        if self.visible {
-            State::One(StateValue::String(format!("{:?}", self.mode)))
-        } else {
-            State::None
-        }
+        State::None
     }
 
-    fn perform(&mut self, cmd: Cmd) -> CmdResult {
-        match cmd {
-            Cmd::Submit => {
-                if let Some(_msg) = self.submit_decision() {
-                    CmdResult::Submit(State::One(StateValue::String("submitted".to_string())))
-                } else {
-                    CmdResult::None
-                }
-            },
-            Cmd::Cancel => {
-                self.hide();
-                CmdResult::Changed(State::None)
-            },
-            _ => CmdResult::None,
-        }
+    fn perform(&mut self, _cmd: Cmd) -> CmdResult {
+        CmdResult::None
     }
 }
+
+/// Helper function to create a centered rectangle
+fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -> Rect {
+    let popup_layout = Layout::default()
+        .direction(Direction::Vertical)
+        .constraints([
+            Constraint::Percentage((100 - percent_y) / 2),
+            Constraint::Percentage(percent_y),
+            Constraint::Percentage((100 - percent_y) / 2),
+        ])
+        .split(r);
+
+    Layout::default()
+        .direction(Direction::Horizontal)
+        .constraints([
+            Constraint::Percentage((100 - percent_x) / 2),
+            Constraint::Percentage(percent_x),
+            Constraint::Percentage((100 - percent_x) / 2),
+        ])
+        .split(popup_layout[1])[1]
+}
+
+// NoUserEvent placeholder (use your actual definition)
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub struct NoUserEvent;
diff --git a/crates/acp-tui/src/components/realm/mod.rs b/crates/acp-tui/src/components/realm/mod.rs
index e08dea8..d0a8576 100644
--- a/crates/acp-tui/src/components/realm/mod.rs
+++ b/crates/acp-tui/src/components/realm/mod.rs
@@ -6,7 +6,6 @@
 pub mod query_input;
 pub mod status_line;
 pub mod hitl_review;
-pub mod hitl_queue;
 pub mod help;
 pub mod root;
 pub mod event_tree;
@@ -14,4 +13,3 @@ pub mod event_tree;
 pub use query_input::QueryInputRealmComponent;
 pub use status_line::StatusLineRealmComponent;
 pub use hitl_review::HitlReviewRealmComponent;
-pub use hitl_queue::HitlQueueRealmComponent;
diff --git a/crates/acp-tui/src/message.rs b/crates/acp-tui/src/message.rs
index 196da90..ef9f71e 100644
--- a/crates/acp-tui/src/message.rs
+++ b/crates/acp-tui/src/message.rs
@@ -66,12 +66,6 @@ pub enum APIEvent {
     /// Query execution failed
     QueryExecutionFailed(String), // error
 
-    // ============== Layout Events ==============
-    /// Switch to normal layout (timeline + query)
-    LayoutNormal,
-    /// Switch to HITL review layout
-    LayoutHitlReview,
-
     // ============== Error Events ==============
     /// General error occurred
     ErrorOccurred(String),
@@ -156,21 +150,6 @@ impl StatusSeverity {
     }
 }
 
-/// Layout modes for the application
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum LayoutMode {
-    /// Normal layout: Timeline + QueryInput + StatusLine
-    Normal,
-    /// HITL review layout: HitlQueue + HitlReview + Timeline (smaller)
-    HitlReview,
-}
-
-impl Default for LayoutMode {
-    fn default() -> Self {
-        LayoutMode::Normal
-    }
-}
-
 /// Component messages generated from keyboard events and UI interactions
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum UserEvent {
@@ -182,13 +161,6 @@ pub enum UserEvent {
     FocusPrevious,
     /// Toggle help overlay
     HelpToggle,
-    /// Submit HITL decision
-    HitlSubmitDecision,
-    /// Cancel HITL review
-    HitlCancelReview,
-    /// Open HITL review
-    HitlOpenReview,
-    /// No action (default for unhandled events)
 
     // ============== Connection Events ==============
     /// Start connection flow (create subscription)
@@ -212,29 +184,17 @@ pub enum UserEvent {
     /// Query execution failed
     QueryExecutionFailed(String), // error
     // ============== HITL Events ==============
-    /// HITL approval request received (using generated type)
-    HitlRequestReceived(HitlApprovalRequest),
-    /// Open HITL review window for specific request
-    HitlReviewOpen(String), // request_id
-    /// Close HITL review window
-    HitlReviewClose,
-    /// HITL decision was made (using generated type)
-    HitlDecisionMade(String, HitlDecisionRequest), // request_id, decision
-    /// HITL decision was sent successfully
-    HitlDecisionSent(String), // request_id
-    /// HITL decision sending failed
-    HitlDecisionFailed(String, String), // request_id, error
+    HitlDecisionSubmit{
+        id: String,
+        approved: bool,
+        modified_content: Option<String>,
+        reasoning: Option<String>,
+    },
 
     // ============== UI Navigation Events ==============
     /// Change focus to next component
     /// Focus specific component
     FocusComponent(ComponentId),
-    // ============== Layout Events ==============
-    /// Switch to normal layout (timeline + query)
-    LayoutNormal,
-    /// Switch to HITL review layout
-    LayoutHitlReview,
-
     // ============== Error Events ==============
     /// General error occurred
     ErrorOccurred(String),
diff --git a/crates/acp-tui/src/services/api.rs b/crates/acp-tui/src/services/api.rs
index 86c5d74..d76f984 100644
--- a/crates/acp-tui/src/services/api.rs
+++ b/crates/acp-tui/src/services/api.rs
@@ -20,7 +20,7 @@ impl ApiService {
     pub fn new(client: Arc<AcpClient>) -> Self {
         Self { client }
     }
-    
+
     /// Retry an async operation with exponential backoff
     async fn retry_with_backoff<T, F, Fut>(&self, operation: F, operation_name: &str) -> Result<T>
     where
@@ -29,20 +29,20 @@ impl ApiService {
     {
         const MAX_RETRIES: u32 = 3;
         const BASE_DELAY_MS: u64 = 100;
-        
+
         let mut last_error = None;
-        
+
         for attempt in 1..=MAX_RETRIES {
             match operation().await {
                 Ok(result) => return Ok(result),
                 Err(e) => {
                     last_error = Some(e);
-                    
+
                     if attempt < MAX_RETRIES {
                         let delay = Duration::from_millis(BASE_DELAY_MS * 2_u64.pow(attempt - 1));
                         warn!(
                             "{} failed (attempt {}/{}), retrying in {:?}: {}",
-                            operation_name, attempt, MAX_RETRIES, delay, 
+                            operation_name, attempt, MAX_RETRIES, delay,
                             last_error.as_ref().unwrap()
                         );
                         tokio::time::sleep(delay).await;
@@ -50,14 +50,14 @@ impl ApiService {
                 }
             }
         }
-        
+
         Err(last_error.unwrap())
     }
-    
+
     /// Execute a query through the ACP API
     pub async fn execute_query(&self, query: String, subscription_id: String) -> Result<String> {
         info!("Executing query: {}", query);
-        
+
         let query_clone = query.clone();
         let subscription_id_clone = subscription_id.clone();
         self.retry_with_backoff(
@@ -73,13 +73,13 @@ impl ApiService {
                         language_distribution: std::collections::HashMap::new(),
                     }
                 });
-                
+
                 let request = QueryRequest {
                     query: query_clone.clone(),
                     project_scope,
                     subscription_id: subscription_id_clone.clone(),
                 };
-                
+
                 // Use the generated client's query_task method (from operationId)
                 match self.client.client().query_task(&request).await {
                     Ok(response) => {
@@ -97,39 +97,16 @@ impl ApiService {
             "Query execution"
         ).await
     }
-    
-    /// Submit HITL decision
-    pub async fn submit_hitl_decision(
-        &self,
-        request_id: String,
-        decision: HitlDecisionRequest,
-    ) -> Result<()> {
-        info!("Submitting HITL decision for request: {}", request_id);
-        
-        // Use the generated client's submit_decision method (from operationId)
-        // The method takes the request body as a parameter directly  
-        match self.client.client().submit_decision(&decision).await
-        {
-            Ok(_) => {
-                info!("HITL decision submitted successfully");
-                Ok(())
-            }
-            Err(e) => {
-                error!("HITL decision submission failed: {}", e);
-                Err(e.into())
-            }
-        }
-    }
-    
+
     /// Create subscription
     pub async fn create_subscription(&self, client_id: String) -> Result<String> {
         info!("Creating subscription for client: {}", client_id);
-        
+
         // Create subscription request using generated API types
         let request = SubscribeRequest {
             client_id: Some(client_id),
         };
-        
+
         // Use the generated client's create_subscription method (from operationId)
         // The method takes the request body as a parameter directly
         match self.client.client().create_subscription(&request).await {
@@ -144,11 +121,11 @@ impl ApiService {
             }
         }
     }
-    
+
     /// Get health status
     pub async fn get_health(&self) -> Result<HealthResponse> {
         debug!("Checking server health");
-        
+
         // Use the generated client's health check method (as shown in client.rs)
         match self.client.client().health_check().await {
             Ok(response) => {
@@ -162,4 +139,4 @@ impl ApiService {
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/crates/acp-tui/src/utils/event_logger.rs b/crates/acp-tui/src/utils/event_logger.rs
index 492f45f..f40eb8e 100644
--- a/crates/acp-tui/src/utils/event_logger.rs
+++ b/crates/acp-tui/src/utils/event_logger.rs
@@ -45,7 +45,6 @@ impl EventLogger {
     /// Log state changes with before/after comparison
     pub fn log_state_change(before: &AppModel, after: &AppModel, trigger: &str) {
         let state_changed = before.focused_component != after.focused_component
-            || before.layout_mode != after.layout_mode
             || before.show_help != after.show_help;
 
         if state_changed {
@@ -54,8 +53,6 @@ impl EventLogger {
                 trigger,
                 focused_before = ?before.focused_component,
                 focused_after = ?after.focused_component,
-                layout_before = ?before.layout_mode,
-                layout_after = ?after.layout_mode,
                 help_toggled = (before.show_help != after.show_help),
                 "State changed"
             );
diff --git a/crates/agent-network/src/agents/base.rs b/crates/agent-network/src/agents/base.rs
index 7ba2bbe..f36dd66 100644
--- a/crates/agent-network/src/agents/base.rs
+++ b/crates/agent-network/src/agents/base.rs
@@ -18,17 +18,18 @@ use tokio::sync::{Mutex, broadcast};
 use tracing::{debug, info, error, warn, instrument, Instrument};
 use std::{collections::{HashMap, HashSet}, sync::Arc};
 use chrono;
-use crate::execution_manager::BufferedEventSender;
+use crate::{execution_manager::BufferedEventSender, hitl::ApprovalDecision};
 use schemars::JsonSchema;
 use anyhow::{Context, Result, anyhow};
 
 use crate::{
-    agents::AgentResult, 
+    agents::AgentResult,
     tools::{ToolResult, ToolSet, ToolExecution},
-    hitl::{RiskAssessment, DefaultApprovalQueue, ApprovalRequest, ApprovalDecision, AuditLogger, AuditEvent},
+    hitl::{RiskAssessment, AuditLogger, AuditEvent},
 };
 use ai_agent_common::RiskLevel;
 
+
 /// ReAct step output for semantic stop conditions
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct ReactStepOutput {
@@ -185,7 +186,6 @@ pub trait TypedAgent: Send + Sync {
         workflow_steps: Vec<WorkflowStep>,
         tools: Arc<ToolSet>,
         status_sender: BufferedEventSender,
-        approval_queue: Option<Arc<DefaultApprovalQueue>>,
         audit_logger: Option<Arc<AuditLogger>>,
     ) -> Result<AgentResult> {
         // Emit agent started event
@@ -193,22 +193,22 @@ pub trait TypedAgent: Send + Sync {
             .as_ref()
             .map(|id| id.to_string())
             .unwrap_or_else(|| "unknown".to_string());
-        
+
         let agent_started_event = StatusEvent {
-            execution_id: conversation_id.clone(),
+            conversation_id: conversation_id.clone(),
             timestamp: chrono::Utc::now(),
-            source: EventSource::Agent { 
-                agent_id: self.id().to_string(), 
+            source: EventSource::Agent {
+                agent_id: self.id().to_string(),
                 agent_type: self.agent_type(),
                 task_id: context.task_id.clone(),
             },
-            event: EventType::AgentStarted { 
-                context_size: context.description.len() + 
+            event: EventType::AgentStarted {
+                context_size: context.description.len() +
                     context.rag_context.as_ref().map(|c| c.len()).unwrap_or(0) +
                     context.history_context.as_ref().map(|c| c.len()).unwrap_or(0)
             },
         };
-        
+
         if let Err(_) = status_sender.send(agent_started_event).await {
             debug!("Failed to send agent started event");
         }
@@ -222,18 +222,18 @@ pub trait TypedAgent: Send + Sync {
 
             // Emit workflow step started event
             let step_started_event = StatusEvent {
-                execution_id: conversation_id.clone(),
+                conversation_id: conversation_id.clone(),
                 timestamp: chrono::Utc::now(),
-                source: EventSource::Agent { 
-                    agent_id: self.id().to_string(), 
+                source: EventSource::Agent {
+                    agent_id: self.id().to_string(),
                     agent_type: self.agent_type(),
                     task_id: context.task_id.clone(),
                 },
-                event: EventType::WorkflowStepStarted { 
+                event: EventType::WorkflowStepStarted {
                     step_name: step.name.clone()
                 },
             };
-            
+
             if let Err(_) = status_sender.send(step_started_event).await {
                 debug!("Failed to send workflow step started event");
             }
@@ -249,7 +249,7 @@ pub trait TypedAgent: Send + Sync {
                     self.execute_step_oneshot(&updated_context, step).await
                 }
                 StepExecutionMode::ReAct { max_iterations } => {
-                    self.execute_step_react(&updated_context, step, Arc::clone(&tools), *max_iterations, &status_sender, &approval_queue, &audit_logger).await
+                    self.execute_step_react(&updated_context, step, Arc::clone(&tools), *max_iterations, &status_sender, &audit_logger).await
                 }
             };
 
@@ -267,21 +267,21 @@ pub trait TypedAgent: Send + Sync {
                     final_result = Some(result.output.unwrap_or_default());
 
                     debug!("Step '{}' completed successfully", step.name);
-                    
+
                     // Emit workflow step completed event
                     let step_completed_event = StatusEvent {
-                        execution_id: conversation_id.clone(),
+                        conversation_id: conversation_id.clone(),
                         timestamp: chrono::Utc::now(),
-                        source: EventSource::Agent { 
-                            agent_id: self.id().to_string(), 
+                        source: EventSource::Agent {
+                            agent_id: self.id().to_string(),
                             agent_type: self.agent_type(),
                             task_id: context.task_id.clone(),
                         },
-                        event: EventType::WorkflowStepCompleted { 
+                        event: EventType::WorkflowStepCompleted {
                             step_name: step.name.clone()
                         },
                     };
-                    
+
                     if let Err(_) = status_sender.send(step_completed_event).await {
                         debug!("Failed to send workflow step completed event");
                     }
@@ -301,18 +301,18 @@ pub trait TypedAgent: Send + Sync {
 
                     // Emit agent failed event
                     let agent_failed_event = StatusEvent {
-                        execution_id: conversation_id.clone(),
+                        conversation_id: conversation_id.clone(),
                         timestamp: chrono::Utc::now(),
-                        source: EventSource::Agent { 
-                            agent_id: self.id().to_string(), 
+                        source: EventSource::Agent {
+                            agent_id: self.id().to_string(),
                             agent_type: self.agent_type(),
                             task_id: context.task_id.clone(),
                         },
-                        event: EventType::AgentFailed { 
+                        event: EventType::AgentFailed {
                             error: error_msg.clone()
                         },
                     };
-                    
+
                     if let Err(_) = status_sender.send(agent_failed_event).await {
                         debug!("Failed to send agent failed event");
                     }
@@ -339,18 +339,18 @@ pub trait TypedAgent: Send + Sync {
 
         // Emit agent completed event
         let agent_completed_event = StatusEvent {
-            execution_id: conversation_id.clone(),
+            conversation_id: conversation_id.clone(),
             timestamp: chrono::Utc::now(),
-            source: EventSource::Agent { 
-                agent_id: self.id().to_string(), 
+            source: EventSource::Agent {
+                agent_id: self.id().to_string(),
                 agent_type: self.agent_type(),
                 task_id: context.task_id.clone(),
             },
-            event: EventType::AgentCompleted { 
+            event: EventType::AgentCompleted {
                 result: agent_result.reasoning.clone().unwrap_or_default()
             },
         };
-        
+
         if let Err(_) = status_sender.send(agent_completed_event).await {
             debug!("Failed to send agent completed event");
         }
@@ -554,7 +554,7 @@ pub trait TypedAgent: Send + Sync {
         let needs_approval = match tool_risk {
             RiskLevel::Critical => true, // Always require approval for critical operations
             RiskLevel::High => confidence < 0.8, // Require approval if not confident
-            RiskLevel::Medium => confidence < 0.6, // Require approval if low confidence  
+            RiskLevel::Medium => confidence < 0.6, // Require approval if low confidence
             RiskLevel::Low => false, // Generally safe
         };
 
@@ -570,8 +570,8 @@ pub trait TypedAgent: Send + Sync {
         status_sender: &BufferedEventSender,
         risk_level: RiskLevel,
     ) -> Result<ApprovalDecision> {
-        let request_id = format!("hitl_{}_{}", 
-            agent_context.task_id.as_ref().unwrap_or(&"unknown".to_string()), 
+        let request_id = format!("hitl_{}_{}",
+            agent_context.task_id.as_ref().unwrap_or(&"unknown".to_string()),
             chrono::Utc::now().timestamp_millis()
         );
 
@@ -586,12 +586,12 @@ pub trait TypedAgent: Send + Sync {
             tool_executions: vec![],
         };
 
-        let risk_assessment = RiskAssessment::new(&agent_result, self.agent_type(), 
+        let risk_assessment = RiskAssessment::new(&agent_result, self.agent_type(),
             Some(format!("Tool {} requires approval: risk={:?}, args={}", tool_name, risk_level, tool_args)));
 
         // Send HITL requested event to notify TUI
         let hitl_event = StatusEvent {
-            execution_id: agent_context.conversation_id
+            conversation_id: agent_context.conversation_id
                 .as_ref()
                 .map(|id| id.to_string())
                 .unwrap_or_else(|| "unknown".to_string()),
@@ -611,6 +611,7 @@ pub trait TypedAgent: Send + Sync {
             warn!("Failed to send HITL requested event");
         }
 
+
         // Create audit event for the request
         let audit_event = AuditEvent {
             event_id: request_id.clone(),
@@ -629,36 +630,72 @@ pub trait TypedAgent: Send + Sync {
 
         AuditLogger::log(audit_event);
 
-        info!("HITL approval requested for {} tool {} (risk: {:?})", 
+        info!("HITL approval requested for {} tool {} (risk: {:?})",
               self.agent_type(), tool_name, risk_level);
 
-        // Apply approval policy based on risk level and business rules
-        let decision = match risk_level {
-            RiskLevel::Critical => {
-                warn!("CRITICAL OPERATION BLOCKED: {} tool {} requires manual approval", 
-                      self.agent_type(), tool_name);
-                // Critical operations always require approval - block for safety
-                ApprovalDecision::Rejected
-            },
-            RiskLevel::High => {
-                warn!("HIGH-RISK OPERATION: {} tool {} requires review", 
-                      self.agent_type(), tool_name);
-                // High-risk operations - for now auto-approve but log for review
-                // In production, this would wait for human decision via API
-                ApprovalDecision::Approved
-            },
-            RiskLevel::Medium => {
-                info!("MEDIUM-RISK OPERATION: {} tool {} auto-approved with monitoring", 
-                      self.agent_type(), tool_name);
-                ApprovalDecision::Approved
-            },
-            RiskLevel::Low => {
-                debug!("LOW-RISK OPERATION: {} tool {} auto-approved", 
-                       self.agent_type(), tool_name);
-                ApprovalDecision::Approved
-            },
+        let decision = match status_sender.recv().await {
+            Ok(event) => {
+                match event {
+                    // TODO: check or receive only message for the respective id
+                    StatusEvent{ conversation_id, timestamp, source, event: EventType::HitlDecision{ id, approved, modified_content, reasoning } } =>{
+                        let decision = if approved{ApprovalDecision::Approved{reasoning}}else{ApprovalDecision::Rejected{reasoning}};
+
+                        // Send completion event
+                        let completion_event = StatusEvent {
+                            conversation_id: agent_context.conversation_id
+                                .as_ref()
+                                .map(|id| id.to_string())
+                                .unwrap_or_else(|| "unknown".to_string()),
+                            timestamp: chrono::Utc::now(),
+                            source: EventSource::Agent {
+                                agent_id: self.id().to_string(),
+                                agent_type: self.agent_type(),
+                                task_id: agent_context.task_id.clone(),
+                            },
+                            event: EventType::HitlCompleted {
+                                approved: matches!(decision, ApprovalDecision::Approved{reasoning: None}),
+                                reason: Some(format!("Policy decision for {:?} risk: {:?}", risk_level, decision)),
+                            },
+                        };
+
+                        if let Err(_) = status_sender.send(completion_event).await {
+                            warn!("Failed to send HITL completed event");
+                        }
+                        decision
+                    },
+                    _ =>{ApprovalDecision::Approved{reasoning: None}}
+                }
+            }
+            Err(err) => {ApprovalDecision::Rejected{reasoning: Some(err.to_string())}}
         };
 
+        // // Apply approval policy based on risk level and business rules
+        // let decision = match risk_level {
+        //     RiskLevel::Critical => {
+        //         warn!("CRITICAL OPERATION BLOCKED: {} tool {} requires manual approval",
+        //               self.agent_type(), tool_name);
+        //         // Critical operations always require approval - block for safety
+        //         ApprovalDecision::Rejected
+        //     },
+        //     RiskLevel::High => {
+        //         warn!("HIGH-RISK OPERATION: {} tool {} requires review",
+        //               self.agent_type(), tool_name);
+        //         // High-risk operations - for now auto-approve but log for review
+        //         // In production, this would wait for human decision via API
+        //         ApprovalDecision::Approved
+        //     },
+        //     RiskLevel::Medium => {
+        //         info!("MEDIUM-RISK OPERATION: {} tool {} auto-approved with monitoring",
+        //               self.agent_type(), tool_name);
+        //         ApprovalDecision::Approved
+        //     },
+        //     RiskLevel::Low => {
+        //         debug!("LOW-RISK OPERATION: {} tool {} auto-approved",
+        //                self.agent_type(), tool_name);
+        //         ApprovalDecision::Approved
+        //     },
+        // };
+
         // Log the final decision
         let decision_audit = AuditEvent {
             event_id: format!("{}_decision", request_id),
@@ -677,28 +714,6 @@ pub trait TypedAgent: Send + Sync {
 
         AuditLogger::log(decision_audit);
 
-        // Send completion event
-        let completion_event = StatusEvent {
-            execution_id: agent_context.conversation_id
-                .as_ref()
-                .map(|id| id.to_string())
-                .unwrap_or_else(|| "unknown".to_string()),
-            timestamp: chrono::Utc::now(),
-            source: EventSource::Agent {
-                agent_id: self.id().to_string(),
-                agent_type: self.agent_type(),
-                task_id: agent_context.task_id.clone(),
-            },
-            event: EventType::HitlCompleted {
-                approved: matches!(decision, ApprovalDecision::Approved),
-                reason: Some(format!("Policy decision for {:?} risk: {:?}", risk_level, decision)),
-            },
-        };
-
-        if let Err(_) = status_sender.send(completion_event).await {
-            warn!("Failed to send HITL completed event");
-        }
-
         info!("HITL decision for {} tool {}: {:?}", self.agent_type(), tool_name, decision);
         Ok(decision)
     }
@@ -724,7 +739,6 @@ pub trait TypedAgent: Send + Sync {
         tools: Arc<ToolSet>,
         max_iterations: Option<usize>,
         status_sender: &BufferedEventSender,
-        approval_queue: &Option<Arc<DefaultApprovalQueue>>,
         audit_logger: &Option<Arc<AuditLogger>>,
     ) -> Result<StepResult> {
         // Record comprehensive input details as span attributes for Jaeger visibility
@@ -831,7 +845,7 @@ pub trait TypedAgent: Send + Sync {
 
                     for tool_call in tool_calls {
                         let function = &tool_call.function;
-                        
+
                         // HITL: Check if this tool requires approval
                         // Use agent's current confidence - for now, estimate from iteration count
                         let estimated_confidence = match iteration {
@@ -840,12 +854,13 @@ pub trait TypedAgent: Send + Sync {
                             2 => 0.5, // Lower confidence on third attempt
                             _ => 0.3, // Low confidence after multiple attempts
                         };
-                        
+
                         let (risk_level, needs_approval) = self.assess_tool_risk(&function.name, estimated_confidence);
-                        
-                        if needs_approval && approval_queue.is_some() {
+
+                        // if needs_approval {
+                        if true{ //TODO: remove, this is just for debugging HITL
                             debug!(target: "agent_execution", "Tool {} requires HITL approval (risk: {:?})", function.name, risk_level);
-                            
+
                             // Add assistant message showing the tool call the agent wants to make
                             messages.push(ChatCompletionRequestMessage::Assistant(
                                 async_openai::types::ChatCompletionRequestAssistantMessageArgs::default()
@@ -853,7 +868,7 @@ pub trait TypedAgent: Send + Sync {
                                     .tool_calls(vec![tool_call.clone()])
                                     .build()?
                             ));
-                            
+
                             match self.request_hitl_approval(
                                 &function.name,
                                 &function.arguments,
@@ -861,8 +876,12 @@ pub trait TypedAgent: Send + Sync {
                                 status_sender,
                                 risk_level,
                             ).await? {
-                                ApprovalDecision::Approved => {
+                                ApprovalDecision::Approved{reasoning} => {
                                     debug!(target: "agent_execution", "HITL approved tool execution: {}", function.name);
+                                    if let Some(reasoning) = reasoning{
+                                        // Add tool result to conversation
+                                        messages.push(ChatCompletionRequestUserMessage::from(format!("## HITL Feedback:\n{}",reasoning)).into());
+                                    }
                                     // Execute tool as normal
                                     let tool_execution = tools.execute_tool(&function.name, &function.arguments).await?;
                                     tool_executions.push(tool_execution.clone());
@@ -875,7 +894,7 @@ pub trait TypedAgent: Send + Sync {
                                             .build()?
                                     ));
                                 }
-                                ApprovalDecision::Rejected => {
+                                ApprovalDecision::Rejected{reasoning} => {
                                     warn!(target: "agent_execution", "HITL rejected tool execution: {}", function.name);
                                     // Add rejection message to conversation
                                     messages.push(ChatCompletionRequestMessage::Tool(
@@ -884,6 +903,11 @@ pub trait TypedAgent: Send + Sync {
                                             .tool_call_id(tool_call.id.clone())
                                             .build()?
                                     ));
+
+                                    if let Some(reasoning) = reasoning{
+                                        // Add tool result to conversation
+                                        messages.push(ChatCompletionRequestUserMessage::from(format!("## HITL Feedback:\n{}",reasoning)).into());
+                                    }
                                 }
                                 ApprovalDecision::NeedsMoreInfo => {
                                     info!(target: "agent_execution", "HITL requested more info for tool: {}", function.name);
@@ -1146,13 +1170,12 @@ pub trait Agent: Send + Sync {
 
     // Execute with type-erased result
     async fn execute(
-        &self, 
+        &self,
         context: AgentContext,
         status_sender: BufferedEventSender,
-        approval_queue: Option<Arc<DefaultApprovalQueue>>,
         audit_logger: Option<Arc<AuditLogger>>,
     ) -> Result<AgentResult>;
-    
+
     /// Define the workflow steps for this agent (from TypedAgent)
     fn define_workflow_steps(&self, context: &AgentContext) -> Vec<WorkflowStep>;
 }
@@ -1169,20 +1192,19 @@ where
     fn model(&self) -> &str { TypedAgent::model(self) }
     fn client(&self) -> &Client<OpenAIConfig> { TypedAgent::client(self) }
 
-    #[instrument(name = "agent_workflow_execution", skip(self, context, status_sender, approval_queue, audit_logger), fields(agent_id = %self.id(), agent_type = %self.agent_type()))]
+    #[instrument(name = "agent_workflow_execution", skip(self, context, status_sender, audit_logger), fields(agent_id = %self.id(), agent_type = %self.agent_type()))]
     async fn execute(
-        &self, 
+        &self,
         context: AgentContext,
         status_sender: BufferedEventSender,
-        approval_queue: Option<Arc<DefaultApprovalQueue>>,
         audit_logger: Option<Arc<AuditLogger>>,
     ) -> Result<AgentResult> {
         // All agents use workflow execution
         let workflow_steps = self.define_workflow_steps(&context);
         let tools = Arc::new(ToolSet::new(&context.clone().project_scope.unwrap().root));
-        self.execute_workflow(context, workflow_steps, tools, status_sender, approval_queue, audit_logger).await
+        self.execute_workflow(context, workflow_steps, tools, status_sender, audit_logger).await
     }
-    
+
     fn define_workflow_steps(&self, context: &AgentContext) -> Vec<WorkflowStep> {
         TypedAgent::define_workflow_steps(self, context)
     }
diff --git a/crates/agent-network/src/execution_manager.rs b/crates/agent-network/src/execution_manager.rs
index 60beffb..7f089b1 100644
--- a/crates/agent-network/src/execution_manager.rs
+++ b/crates/agent-network/src/execution_manager.rs
@@ -11,14 +11,14 @@ use std::sync::Arc;
 use std::time::{Duration, Instant};
 use tokio::sync::{broadcast, RwLock};
 use uuid::Uuid;
-use anyhow::Result;
+use anyhow::{Context, Result};
 use tracing::{debug, info, warn, error, instrument};
 use chrono::{DateTime, Utc};
 
 use crate::agents::AgentPool;
 use crate::coordination::CoordinationManager;
 use crate::filelocks::FileLockManager;
-use crate::hitl::{AuditLogger, DefaultApprovalQueue};
+use crate::hitl::{AuditLogger};
 use crate::sharedcontext::SharedContext;
 use crate::orchestrator::Orchestrator;
 
@@ -56,8 +56,8 @@ impl Subscription {
         let id = format!("sub_{}", Uuid::new_v4());
         let now = Utc::now();
         let expires_at = now + chrono::Duration::minutes(ttl_minutes);
-        let (sender, _) = broadcast::channel(1000);
-        
+        let (sender, receiver) = broadcast::channel(1000);
+
         Self {
             id,
             client_id,
@@ -69,58 +69,67 @@ impl Subscription {
             sender: Arc::new(sender),
         }
     }
-    
+    /// Add event to buffer and broadcast if connected
+    pub async fn get_event(&mut self) -> Result<StatusEvent, broadcast::error::RecvError> {
+        // Update activity timestamp
+        self.last_activity = Utc::now();
+        let mut receiver = self.sender.subscribe();
+
+        // Broadcast if connected
+        receiver.recv().await
+    }
+
     /// Add event to buffer and broadcast if connected
     pub fn add_event(&mut self, event: StatusEvent) {
         // Update activity timestamp
         self.last_activity = Utc::now();
-        
+
         // Always buffer events
         self.event_buffer.push_back(event.clone());
-        
+
         // Limit buffer size to prevent memory issues
         if self.event_buffer.len() > 500 {
             self.event_buffer.pop_front();
         }
-        
+
         // Broadcast if connected
         if self.connected {
             let _ = self.sender.send(event);
         }
     }
-    
+
     /// Connect WebSocket and get receiver with replay
     pub fn connect(&mut self) -> broadcast::Receiver<StatusEvent> {
         self.connected = true;
         self.last_activity = Utc::now();
-        
+
         // Create receiver
         let receiver = self.sender.subscribe();
-        
+
         // Replay buffered events
         for event in &self.event_buffer {
             let _ = self.sender.send(event.clone());
         }
-        
+
         receiver
     }
-    
+
     /// Disconnect WebSocket (but keep subscription alive for reconnection)
     pub fn disconnect(&mut self) {
         self.connected = false;
         self.last_activity = Utc::now();
     }
-    
+
     /// Check if subscription has expired
     pub fn is_expired(&self) -> bool {
         Utc::now() > self.expires_at
     }
-    
+
     /// Check if any query has been executed (has any events in buffer)
     pub fn has_executed_query(&self) -> bool {
         !self.event_buffer.is_empty()
     }
-    
+
     /// Check if subscription has been inactive for too long (for cleanup)
     pub fn is_inactive(&self, max_inactivity: chrono::Duration) -> bool {
         Utc::now() - self.last_activity > max_inactivity
@@ -154,11 +163,24 @@ impl BufferedEventSender {
             subscriptions,
         }
     }
-    
+
     /// Send an event, routing it through the subscription's buffering mechanism
+    pub async fn recv(&self) -> Result<StatusEvent, broadcast::error::RecvError> {
+        let mut subscriptions = self.subscriptions.write().await;
+
+        if let Some(subscription) = subscriptions.get_mut(&self.subscription_id) {
+            let event = subscription.get_event().await;
+            event
+        } else {
+            warn!("Tried to send event for unknown subscription: {}", self.subscription_id);
+            Err(broadcast::error::RecvError::Closed)
+        }
+    }
+
+    /// Receive an event, routing it through the subscription's buffering mechanism
     pub async fn send(&self, event: StatusEvent) -> Result<(), broadcast::error::SendError<StatusEvent>> {
         let mut subscriptions = self.subscriptions.write().await;
-        
+
         if let Some(subscription) = subscriptions.get_mut(&self.subscription_id) {
             subscription.add_event(event.clone());
             Ok(())
@@ -173,26 +195,24 @@ impl BufferedEventSender {
 pub struct ExecutionManager {
     /// Active subscriptions for buffered streaming
     subscriptions: Arc<RwLock<HashMap<String, Subscription>>>,
-    
+
     /// System configuration
     config: Arc<SystemConfig>,
-    
+
     /// Agent pool for task execution
     agent_pool: Arc<AgentPool>,
-    
+
     /// Shared context across agents
     shared_context: Arc<RwLock<SharedContext>>,
-    
+
     /// Task coordination
     coordination: Arc<CoordinationManager>,
-    
+
     /// File lock manager
     file_locks: Arc<FileLockManager>,
-    
-    /// HITL components
-    approval_queue: Arc<DefaultApprovalQueue>,
+
     audit_logger: Arc<AuditLogger>,
-    
+
     /// RAG and history
     rag: Arc<SmartMultiSourceRag>,
     history_manager: Arc<RwLock<HistoryManager>>,
@@ -204,39 +224,32 @@ impl ExecutionManager {
     #[instrument(name = "execution_manager_init", skip(config), fields(agents = config.agent_network.agents.len()))]
     pub async fn new(config: SystemConfig) -> Result<Self> {
         info!("Initializing ExecutionManager");
-        
+
         // Initialize all components
         let agent_pool = Arc::new(AgentPool::new(&config.agent_network.agents).await?);
         let shared_context = Arc::new(RwLock::new(SharedContext::new()));
         let coordination = Arc::new(CoordinationManager::new());
         let file_locks = Arc::new(FileLockManager::new(30));
-        
+
         // HITL setup
         let hitl_mode = config.agent_network.hitl.mode;
         let risk_threshold = config.agent_network.hitl.risk_threshold;
-        let approval_queue = Arc::new(DefaultApprovalQueue::new(hitl_mode, risk_threshold));
         let audit_logger = Arc::new(AuditLogger);
-        
-        // Spawn approval handler background task
-        let queue_clone = Arc::clone(&approval_queue);
-        let handler = Arc::new(crate::hitl::ConsoleApprovalHandler);
-        tokio::spawn(async move {
-            queue_clone.run_approver(handler).await;
-        });
-        
+
+
         // RAG and history setup
         let embedding_client = Arc::new(EmbeddingClient::new(
-            &config.embedding.dense_model, 
+            &config.embedding.dense_model,
             config.embedding.vector_size
         )?);
-        
+
         let rag = SmartMultiSourceRag::new(&config, embedding_client.clone()).await?;
         let history_manager = Arc::new(RwLock::new(
             HistoryManager::new(&config.storage.postgres_url, &config.rag).await?
         ));
-        
+
         info!("ExecutionManager initialized successfully");
-        
+
         Ok(Self {
             subscriptions: Arc::new(RwLock::new(HashMap::new())),
             config: Arc::new(config),
@@ -244,14 +257,13 @@ impl ExecutionManager {
             shared_context,
             coordination,
             file_locks,
-            approval_queue,
             audit_logger,
             rag,
             history_manager,
             embedding_client,
         })
     }
-    
+
     /// Execute a user query with subscription_id - returns subscription_id, streams progress
     #[instrument(name = "execute_query", skip(self))]
     pub async fn execute_query(
@@ -261,57 +273,56 @@ impl ExecutionManager {
         subscription_id: &str,
     ) -> Result<String> {
         info!("Processing query with subscription: {}", subscription_id);
-        
+
         // Get subscription and mark as executed
         let mut subscriptions = self.subscriptions.write().await;
         let subscription = subscriptions.get_mut(subscription_id)
             .ok_or_else(|| anyhow::anyhow!("Subscription '{}' not found", subscription_id))?;
-        
+
         if subscription.is_expired() {
             return Err(anyhow::anyhow!("Subscription '{}' has expired", subscription_id));
         }
-        
+
         drop(subscriptions);
-        
+
         // Generate a unique execution ID for this query
         let execution_id = Uuid::new_v4().to_string();
-        
+
         // Emit execution started event
         let start_event = StatusEvent {
-            execution_id: execution_id.clone(),
+            conversation_id: execution_id.clone(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
-            event: EventType::ExecutionStarted { 
-                query: query.to_string() 
+            event: EventType::ExecutionStarted {
+                query: query.to_string()
             },
         };
         self.emit_subscription_event(subscription_id, start_event).await;
-        
+
         // Clone data for background execution
         let query_clone = query.to_string();
         let project_scope_clone = project_scope.clone();
         let subscription_id_clone = subscription_id.to_string();
         let execution_id_clone = execution_id.clone();
-        
+
         // Clone all components for background task
         let config = Arc::clone(&self.config);
         let agent_pool = Arc::clone(&self.agent_pool);
         let shared_context = Arc::clone(&self.shared_context);
         let coordination = Arc::clone(&self.coordination);
         let file_locks = Arc::clone(&self.file_locks);
-        let approval_queue = Arc::clone(&self.approval_queue);
         let audit_logger = Arc::clone(&self.audit_logger);
         let rag = Arc::clone(&self.rag);
         let history_manager = Arc::clone(&self.history_manager);
         let embedding_client = Arc::clone(&self.embedding_client);
         let subscriptions = Arc::clone(&self.subscriptions);
-        
+
         // Create buffered event sender for this subscription
         let event_sender = BufferedEventSender::new(subscription_id_clone.clone(), subscriptions.clone());
-        
+
         // Generate a ConversationId for the orchestrator
         let conversation_id = ConversationId::new();
-        
+
         // Start background execution with stateless orchestrator
         tokio::spawn(async move {
             let result = Orchestrator::execute_query(
@@ -324,17 +335,16 @@ impl ExecutionManager {
                 shared_context,
                 coordination,
                 file_locks,
-                approval_queue,
                 audit_logger,
                 rag,
                 history_manager,
                 embedding_client,
             ).await;
-            
+
             // Emit completion/failure event
             let completion_event = match result {
                 Ok(result) => StatusEvent {
-                    execution_id: execution_id_clone.clone(),
+                    conversation_id: execution_id_clone.clone(),
                     timestamp: chrono::Utc::now(),
                     source: EventSource::Orchestrator,
                     event: EventType::ExecutionCompleted { result },
@@ -342,46 +352,46 @@ impl ExecutionManager {
                 Err(e) => {
                     error!("Execution failed for subscription {}: {}", subscription_id_clone, e);
                     StatusEvent {
-                        execution_id: execution_id_clone.clone(),
+                        conversation_id: execution_id_clone.clone(),
                         timestamp: chrono::Utc::now(),
                         source: EventSource::Orchestrator,
-                        event: EventType::ExecutionFailed { 
-                            error: e.to_string() 
+                        event: EventType::ExecutionFailed {
+                            error: e.to_string()
                         },
                     }
                 },
             };
-            
+
             // Emit final event to subscription
             let mut subs = subscriptions.write().await;
             if let Some(subscription) = subs.get_mut(&subscription_id_clone) {
                 subscription.add_event(completion_event);
             }
         });
-        
+
         // Return subscription_id confirming execution started
         Ok(subscription_id.to_string())
     }
-    
+
     // ============== Subscription Event Management ==============
-    
+
     /// Emit a status event to a specific subscription
     pub async fn emit_subscription_event(&self, subscription_id: &str, event: StatusEvent) {
         let mut subscriptions = self.subscriptions.write().await;
-        
+
         if let Some(subscription) = subscriptions.get_mut(subscription_id) {
             subscription.add_event(event);
         } else {
             warn!("Tried to emit event for unknown subscription: {}", subscription_id);
         }
     }
-    
+
     // ============== Subscription Management ==============
-    
+
     /// Create a new subscription or resume existing one by client_id
     pub async fn create_subscription(&self, client_id: Option<String>) -> Result<Subscription> {
         let mut subscriptions = self.subscriptions.write().await;
-        
+
         // Check if client_id already has an active subscription to resume
         if let Some(ref cid) = client_id {
             for subscription in subscriptions.values_mut() {
@@ -395,28 +405,28 @@ impl ExecutionManager {
                 }
             }
         }
-        
+
         // Create new subscription with 5 minute TTL
         let subscription = Subscription::new(client_id.clone(), 5);
         let subscription_id = subscription.id.clone();
-        
+
         info!(
             subscription_id = %subscription_id,
             client_id = ?client_id,
             "Created new subscription"
         );
-        
+
         // Store subscription
         let result = subscription.clone();
         subscriptions.insert(subscription_id.clone(), subscription);
-        
+
         Ok(result)
     }
-    
+
     /// Get subscription and connect WebSocket for streaming
     pub async fn connect_subscription(&self, subscription_id: &str) -> Option<broadcast::Receiver<StatusEvent>> {
         let mut subscriptions = self.subscriptions.write().await;
-        
+
         if let Some(subscription) = subscriptions.get_mut(subscription_id) {
             if subscription.is_expired() {
                 warn!("Attempted to connect to expired subscription: {}", subscription_id);
@@ -430,21 +440,21 @@ impl ExecutionManager {
             None
         }
     }
-    
+
     /// Disconnect WebSocket from subscription
     pub async fn disconnect_subscription(&self, subscription_id: &str) {
         let mut subscriptions = self.subscriptions.write().await;
-        
+
         if let Some(subscription) = subscriptions.get_mut(subscription_id) {
             info!("Disconnecting WebSocket from subscription: {}", subscription_id);
             subscription.disconnect();
         }
     }
-    
+
     /// Get subscription status
     pub async fn get_subscription_status(&self, subscription_id: &str) -> Option<SubscriptionStatusInfo> {
         let subscriptions = self.subscriptions.read().await;
-        
+
         if let Some(subscription) = subscriptions.get(subscription_id) {
             let status = if subscription.is_expired() {
                 "expired"
@@ -455,7 +465,7 @@ impl ExecutionManager {
             } else {
                 "waiting"
             };
-            
+
             Some(SubscriptionStatusInfo {
                 subscription_id: subscription.id.clone(),
                 status: status.to_string(),
@@ -469,16 +479,16 @@ impl ExecutionManager {
             None
         }
     }
-    
-    
+
+
     /// Clean up expired and inactive subscriptions
     pub async fn cleanup_expired_subscriptions(&self) {
         let mut subscriptions = self.subscriptions.write().await;
         let initial_count = subscriptions.len();
-        
+
         // Clean up subscriptions that are expired OR inactive for >30 minutes
         let max_inactivity = chrono::Duration::minutes(30);
-        
+
         subscriptions.retain(|subscription_id, subscription| {
             if subscription.is_expired() {
                 info!("Cleaning up expired subscription: {}", subscription_id);
@@ -495,10 +505,10 @@ impl ExecutionManager {
                 true
             }
         });
-        
+
         let cleaned_count = initial_count - subscriptions.len();
         if cleaned_count > 0 {
             info!("Cleaned up {} expired/inactive subscriptions", cleaned_count);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/crates/agent-network/src/hitl/assessor.rs b/crates/agent-network/src/hitl/assessor.rs
index 3455113..a5cf1c5 100644
--- a/crates/agent-network/src/hitl/assessor.rs
+++ b/crates/agent-network/src/hitl/assessor.rs
@@ -3,7 +3,7 @@
 use ai_agent_common::HitlMode;
 
 use crate::{
-    hitl::{HitlRequest, RiskLevel},
+    hitl::{RiskLevel},
 };
 use crate::error::AgentNetworkResult;
 
diff --git a/crates/agent-network/src/hitl/mod.rs b/crates/agent-network/src/hitl/mod.rs
index 4e2b40a..1b11bea 100644
--- a/crates/agent-network/src/hitl/mod.rs
+++ b/crates/agent-network/src/hitl/mod.rs
@@ -4,20 +4,34 @@
 
 pub mod assessor;
 pub mod audit;
-pub mod queue;
 
 use std::collections::HashMap;
 
 use ai_agent_common::{AgentType, RiskLevel};
 pub use assessor::*;
 pub use audit::*;
-pub use queue::*;
 
 use serde::{Deserialize, Serialize};
 use anyhow::Result;
 
 use crate::AgentResult;
 
+
+#[derive(Debug, Clone)]
+pub struct ApprovalRequest {
+    pub request_id: String,
+    pub assessment: RiskAssessment,
+    pub decision: Option<ApprovalDecision>,
+}
+
+#[derive(Debug, Clone, PartialEq, Eq, Hash)]
+pub enum ApprovalDecision {
+    Approved{ reasoning: Option<String> },
+    Rejected{ reasoning: Option<String> },
+    NeedsMoreInfo,
+}
+
+
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct HitlRequest {
     pub request_id: String,
diff --git a/crates/agent-network/src/hitl/queue.rs b/crates/agent-network/src/hitl/queue.rs
deleted file mode 100644
index 2b2d9be..0000000
--- a/crates/agent-network/src/hitl/queue.rs
+++ /dev/null
@@ -1,94 +0,0 @@
-//! Approval Queue for HITL
-
-use ai_agent_common::HitlMode;
-use async_trait::async_trait;
-use std::collections::{HashMap, VecDeque};
-use std::sync::Arc;
-use tokio::sync::{Mutex, Notify};
-use tracing::{info, warn};
-
-use crate::hitl::{RiskAssessment, RiskLevel};
-
-
-#[derive(Debug, Clone)]
-pub struct ApprovalRequest {
-    pub request_id: String,
-    pub assessment: RiskAssessment,
-    pub decision: Option<ApprovalDecision>,
-}
-
-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
-pub enum ApprovalDecision {
-    Approved,
-    Rejected,
-    NeedsMoreInfo,
-}
-
-#[async_trait]
-pub trait ApprovalHandler: Send + Sync {
-    async fn request_approval(&self, req: ApprovalRequest) -> ApprovalDecision;
-}
-
-#[derive(Debug, Clone)]
-pub struct DefaultApprovalQueue {
-    pub mode: HitlMode,
-    pub risk_threshold: RiskLevel,
-    queue: Arc<Mutex<VecDeque<ApprovalRequest>>>,
-    notify: Arc<Notify>,
-}
-
-impl DefaultApprovalQueue {
-    pub fn new(mode: HitlMode, risk_threshold: RiskLevel) -> Self {
-        Self {
-            mode,
-            risk_threshold,
-            queue: Arc::new(Mutex::new(VecDeque::new())),
-            notify: Arc::new(Notify::new()),
-        }
-    }
-
-    pub async fn enqueue(&self, req: ApprovalRequest) {
-        let mut queue = self.queue.lock().await;
-        queue.push_back(req);
-        self.notify.notify_one();
-    }
-
-    pub async fn run_approver<H: ApprovalHandler + 'static>(self: Arc<Self>, handler: Arc<H>) {
-        loop {
-            let req_opt = {
-                let mut queue = self.queue.lock().await;
-                queue.pop_front()
-            };
-            match req_opt {
-                Some(mut req) => {
-                    let decision = handler.request_approval(req.clone()).await;
-                    req.decision = Some(decision);
-                    info!(
-                        "Approval decision ({}): {:?}",
-                        req.request_id, req.decision
-                    );
-                }
-                None => self.notify.notified().await,
-            }
-        }
-    }
-}
-
-pub struct ConsoleApprovalHandler;
-
-#[async_trait]
-impl ApprovalHandler for ConsoleApprovalHandler {
-    async fn request_approval(&self, req: ApprovalRequest) -> ApprovalDecision {
-        use ApprovalDecision::*;
-        println!("\nHITL Approval Required: {:?}", req.assessment);
-        println!("Enter 'a' to approve, 'r' to reject, 'm' for more info:");
-        let mut buf = String::new();
-        std::io::stdin().read_line(&mut buf).unwrap();
-        match buf.trim() {
-            "a" => Approved,
-            "r" => Rejected,
-            "m" => NeedsMoreInfo,
-            _ => NeedsMoreInfo,
-        }
-    }
-}
diff --git a/crates/agent-network/src/orchestrator.rs b/crates/agent-network/src/orchestrator.rs
index 6fcbb15..fa52f8c 100644
--- a/crates/agent-network/src/orchestrator.rs
+++ b/crates/agent-network/src/orchestrator.rs
@@ -20,7 +20,7 @@ use crate::agents::planning::{SubtaskSpec, TaskDecompositionPlan};
 use crate::sharedcontext::SharedContext;
 use crate::coordination::CoordinationManager;
 use crate::filelocks::FileLockManager;
-use crate::hitl::{AuditLogger, DefaultApprovalQueue};
+use crate::hitl::{AuditLogger};
 use crate::workflow::{WorkflowExecutor, WorkflowGraph, TaskResult, WorkflowBuilder, TaskNode, DependencyType};
 use crate::execution_manager::BufferedEventSender;
 use schemars::JsonSchema;
@@ -110,30 +110,29 @@ impl Orchestrator {
         shared_context: Arc<RwLock<SharedContext>>,
         coordination: Arc<CoordinationManager>,
         file_locks: Arc<FileLockManager>,
-        approval_queue: Arc<DefaultApprovalQueue>,
         audit_logger: Arc<AuditLogger>,
         rag: Arc<SmartMultiSourceRag>,
         history_manager: Arc<RwLock<HistoryManager>>,
         embedding_client: Arc<EmbeddingClient>,
     ) -> Result<String> {
         info!("Processing query: {}", query);
-        
+
         let conversation_id_str = conversation_id.to_string();
 
         // Step 1: Analyze the query
         let analysis = Self::analyze_query(query, &config.agent_network).await?;
         debug!("Query analysis: {:?}", analysis);
-        
+
         // Emit query analysis completed event
         let analysis_event = StatusEvent {
-            execution_id: conversation_id_str.clone(),
+            conversation_id: conversation_id_str.clone(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
-            event: EventType::WorkflowStepCompleted { 
+            event: EventType::WorkflowStepCompleted {
                 step_name: format!("Query Analysis ({})", analysis.complexity as u8)
             },
         };
-        
+
         if let Err(_) = status_sender.send(analysis_event).await {
             debug!("Failed to send query analysis event");
         }
@@ -143,10 +142,10 @@ impl Orchestrator {
             Complexity::Trivial | Complexity::Simple => {
                 info!("Simple task detected, routing directly to appropriate agent");
                 Self::route_to_single_agent(
-                    &analysis, 
-                    &project_scope, 
-                    &conversation_id, 
-                    &agent_pool, 
+                    &analysis,
+                    &project_scope,
+                    &conversation_id,
+                    &agent_pool,
                     &config.agent_network
                 ).await?
             },
@@ -163,17 +162,17 @@ impl Orchestrator {
             }
         };
         info!("Generated {} tasks", tasks.len());
-        
+
         // Emit task decomposition completed event
         let decomposition_event = StatusEvent {
-            execution_id: conversation_id_str.clone(),
+            conversation_id: conversation_id_str.clone(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
-            event: EventType::WorkflowStepCompleted { 
+            event: EventType::WorkflowStepCompleted {
                 step_name: format!("Task Decomposition ({} tasks)", tasks.len())
             },
         };
-        
+
         if let Err(_) = status_sender.send(decomposition_event).await {
             debug!("Failed to send task decomposition event");
         }
@@ -181,30 +180,29 @@ impl Orchestrator {
         // Step 3: Build workflow DAG
         let workflow = Self::build_workflow(&tasks).await?;
         debug!("Built workflow with {} nodes", workflow.node_count());
-        
+
         // Emit workflow construction completed event
         let workflow_event = StatusEvent {
-            execution_id: conversation_id_str.clone(),
+            conversation_id: conversation_id_str.clone(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
-            event: EventType::WorkflowStepCompleted { 
+            event: EventType::WorkflowStepCompleted {
                 step_name: format!("Workflow Construction ({} nodes)", workflow.node_count())
             },
         };
-        
+
         if let Err(_) = status_sender.send(workflow_event).await {
             debug!("Failed to send workflow construction event");
         }
 
         // Step 4: Execute workflow
         let results = Self::execute_workflow(
-            workflow, 
-            project_scope, 
+            workflow,
+            project_scope,
             conversation_id,
             agent_pool,
             coordination,
             file_locks,
-            approval_queue,
             audit_logger,
             rag,
             history_manager,
@@ -214,17 +212,17 @@ impl Orchestrator {
 
         // Step 5: Synthesize results
         let final_result = Self::synthesize_results(&results).await?;
-        
+
         // Emit result synthesis completed event
         let synthesis_event = StatusEvent {
-            execution_id: conversation_id_str.clone(),
+            conversation_id: conversation_id_str.clone(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
-            event: EventType::WorkflowStepCompleted { 
+            event: EventType::WorkflowStepCompleted {
                 step_name: format!("Result Synthesis ({} chars)", final_result.len())
             },
         };
-        
+
         if let Err(_) = status_sender.send(synthesis_event).await {
             debug!("Failed to send result synthesis event");
         }
@@ -347,7 +345,7 @@ impl Orchestrator {
                 "Task {}: id='{}', agent_id='{}', dependencies={:?}",
                 idx, task.id, task.agent_id, task.dependencies
             );
-            
+
             // Add dependencies between tasks
             for from_id in &task.dependencies {
                 builder.add_dependency(&from_id, &task.id, DependencyType::Sequential)?;
@@ -369,7 +367,6 @@ impl Orchestrator {
         agent_pool: Arc<AgentPool>,
         coordination: Arc<CoordinationManager>,
         file_locks: Arc<FileLockManager>,
-        approval_queue: Arc<DefaultApprovalQueue>,
         audit_logger: Arc<AuditLogger>,
         rag: Arc<SmartMultiSourceRag>,
         history_manager: Arc<RwLock<HistoryManager>>,
@@ -383,17 +380,16 @@ impl Orchestrator {
             coordination,
             file_locks,
         );
-        
+
         // Execute the workflow with HITL
         let results = executor.execute_with_hitl(
             workflow,
-            approval_queue,
-            audit_logger, 
-            project_scope, 
+            audit_logger,
+            project_scope,
             conversation_id,
             status_sender,
         ).await?;
-        
+
         Ok(results)
     }
 
@@ -411,12 +407,12 @@ impl Orchestrator {
 
         // Emit planning started event
         let planning_started_event = StatusEvent {
-            execution_id: conversation_id.to_string(),
+            conversation_id: conversation_id.to_string(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
             event: EventType::PlanningStarted,
         };
-        
+
         if let Err(_) = status_sender.send(planning_started_event).await {
             debug!("Failed to send planning started event");
         }
@@ -469,7 +465,7 @@ impl Orchestrator {
         info!("Planning Context: {}", description);
 
         // Execute planning agent with extractor for structured output
-        let result = planning_agent.execute(planning_context, status_sender.clone(), None, None).await?;
+        let result = planning_agent.execute(planning_context, status_sender.clone(), None).await?;
 
         // Extract the structured plan
         let plan: TaskDecompositionPlan = result.extract()
@@ -546,7 +542,7 @@ impl Orchestrator {
 
         // Emit planning completed event
         let planning_completed_event = StatusEvent {
-            execution_id: conversation_id.to_string(),
+            conversation_id: conversation_id.to_string(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
             event: EventType::PlanningCompleted {
@@ -554,7 +550,7 @@ impl Orchestrator {
                 reasoning: plan.reasoning,
             },
         };
-        
+
         if let Err(_) = status_sender.send(planning_completed_event).await {
             debug!("Failed to send planning completed event");
         }
@@ -595,4 +591,4 @@ impl Orchestrator {
 
         Ok(output)
     }
-}
\ No newline at end of file
+}
diff --git a/crates/agent-network/src/workflow/executor.rs b/crates/agent-network/src/workflow/executor.rs
index b18ba9d..b3d3a0e 100644
--- a/crates/agent-network/src/workflow/executor.rs
+++ b/crates/agent-network/src/workflow/executor.rs
@@ -5,7 +5,7 @@
 //! while maximizing parallelism through concurrent task spawning.
 use tracing::{info, debug, warn, error, instrument, span, Level, Instrument};
 use crate::error::{AgentNetworkError, AgentNetworkResult};
-use crate::hitl::{ApprovalRequest, AuditEvent, AuditLogger, DefaultApprovalQueue, RiskAssessment};
+use crate::hitl::{ApprovalRequest, AuditEvent, AuditLogger, RiskAssessment};
 use crate::workflow::{TaskNode, TaskResult, WorkflowGraph, DependencyType};
 use crate::agents::{AgentPool, AgentContext};
 use crate::tools::ToolSet;
@@ -147,7 +147,6 @@ impl WorkflowExecutor {
     #[instrument(name = "workflow_execution", skip(self, graph, status_sender), fields(task_count = %graph.node_count()))]
     pub async fn execute_with_hitl(&self,
             graph: WorkflowGraph,
-            approval_queue: Arc<DefaultApprovalQueue>,
             audit_logger: Arc<AuditLogger>,
             project_scope: ProjectScope,
             conversation_id: ConversationId,
@@ -174,14 +173,14 @@ impl WorkflowExecutor {
         // Create and send ExecutionPlan
         let execution_plan = self.create_execution_plan(&graph, &waves).await?;
         let execution_plan_event = StatusEvent {
-            execution_id: conversation_id.to_string(),
+            conversation_id: conversation_id.to_string(),
             timestamp: chrono::Utc::now(),
             source: EventSource::Orchestrator,
             event: EventType::ExecutionPlanReady {
                 plan: execution_plan,
             },
         };
-        
+
         if let Err(_) = status_sender.send(execution_plan_event).await {
             debug!("Failed to send execution plan event");
         }
@@ -195,7 +194,6 @@ impl WorkflowExecutor {
                 &graph,
                 wave,
                 &all_results,
-                Arc::clone(&approval_queue),
                 Arc::clone(&audit_logger),
                 project_scope.clone(),
                 conversation_id.clone(),
@@ -237,7 +235,6 @@ impl WorkflowExecutor {
         graph: &WorkflowGraph,
         wave: &ExecutionWave,
         previous_results: &HashMap<String, TaskResult>,
-        approval_queue: Arc<DefaultApprovalQueue>,
         audit_logger: Arc<AuditLogger>,
         project_scope: ProjectScope,
         conversation_id: ConversationId,
@@ -255,9 +252,9 @@ impl WorkflowExecutor {
         let task_ids: Vec<String> = wave.task_indices.iter()
             .map(|&idx| graph[idx].task_id.clone())
             .collect();
-        
+
         let wave_started_event = ai_agent_common::StatusEvent {
-            execution_id: conversation_id.to_string(),
+            conversation_id: conversation_id.to_string(),
             timestamp: chrono::Utc::now(),
             source: ai_agent_common::EventSource::Orchestrator,
             event: ai_agent_common::EventType::WaveStarted {
@@ -266,7 +263,7 @@ impl WorkflowExecutor {
                 task_ids,
             },
         };
-        
+
         if let Err(_) = status_sender.send(wave_started_event).await {
             debug!("Failed to send wave started event");
         }
@@ -282,7 +279,6 @@ impl WorkflowExecutor {
             let timeout = self.config.task_timeout;
             let max_retries = self.config.max_retries;
             let wave_index = wave.wave_index;
-            let approval_queue_clone = Arc::clone(&approval_queue);
             let audit_logger_clone = Arc::clone(&audit_logger);
             let context_provider = self.context_provider.clone();
 
@@ -307,7 +303,6 @@ impl WorkflowExecutor {
                         agent_pool,
                         coordination,
                         file_locks,
-                        approval_queue_clone,
                         audit_logger_clone,
                         context_provider,
                         timeout,
@@ -369,7 +364,7 @@ impl WorkflowExecutor {
 
         // Emit wave completed event
         let wave_completed_event = ai_agent_common::StatusEvent {
-            execution_id: conversation_id.to_string(),
+            conversation_id: conversation_id.to_string(),
             timestamp: chrono::Utc::now(),
             source: ai_agent_common::EventSource::Orchestrator,
             event: ai_agent_common::EventType::WaveCompleted {
@@ -378,7 +373,7 @@ impl WorkflowExecutor {
                 failure_count,
             },
         };
-        
+
         if let Err(_) = status_sender.send(wave_completed_event).await {
             debug!("Failed to send wave completed event");
         }
@@ -456,10 +451,10 @@ impl WorkflowExecutor {
 
         for wave in waves {
             let mut wave_tasks = vec![];
-            
+
             for &node_idx in &wave.task_indices {
                 let task_node = &graph[node_idx];
-                
+
                 // Get agent to determine agent_type
                 let agent = self.agent_pool
                     .get_agent(&task_node.agent_id)
@@ -480,7 +475,7 @@ impl WorkflowExecutor {
                         "temp".to_string(),
                         Some(task_node.task_id.clone())
                     );
-                    
+
                     agent.define_workflow_steps(&temp_context)
                         .iter()
                         .map(|step| step.name.clone())
@@ -516,7 +511,7 @@ impl WorkflowExecutor {
 
 
 /// Execute a single task
-#[instrument(name = "task_execution", skip(agent_pool, approval_queue, audit_logger, context_provider, file_locks, previous_results), fields(
+#[instrument(name = "task_execution", skip(agent_pool, audit_logger, context_provider, file_locks, previous_results), fields(
     task_id = %task.task_id,
     agent_id = %task.agent_id,
     description = %task.description
@@ -524,7 +519,6 @@ impl WorkflowExecutor {
 async fn execute_single_task(
     task: TaskNode,
     agent_pool: Arc<AgentPool>,
-    approval_queue: Arc<DefaultApprovalQueue>,
     audit_logger: Arc<AuditLogger>,
     context_provider: Option<Arc<crate::rag::ContextProvider>>,
     file_locks: Arc<FileLockManager>,
@@ -623,9 +617,8 @@ async fn execute_single_task(
 
     // Execute agent
     info!("Starting agent execution");
-    let hitl_approval_queue = Some(approval_queue.clone());
     let hitl_audit_logger = Some(audit_logger.clone());
-    match agent.execute(agent_context, status_sender, hitl_approval_queue, hitl_audit_logger).await {
+    match agent.execute(agent_context, status_sender, hitl_audit_logger).await {
         Ok(result) => {
             info!("Agent execution completed successfully (tool executions: {})", result.tool_executions.len());
 
@@ -656,7 +649,7 @@ async fn execute_single_task(
     }
 }
 
-#[instrument(name = "task_retry_execution", skip(task, agent_pool, coordination, file_locks, approval_queue, audit_logger, context_provider, status_sender, previous_results), fields(
+#[instrument(name = "task_retry_execution", skip(task, agent_pool, coordination, file_locks, audit_logger, context_provider, status_sender, previous_results), fields(
     task_id = %task.task_id,
     agent_id = %task.agent_id,
 ))]
@@ -666,7 +659,6 @@ async fn execute_task_with_retry(
     agent_pool: Arc<AgentPool>,
     coordination: Arc<CoordinationManager>,
     file_locks: Arc<FileLockManager>,
-    approval_queue: Arc<DefaultApprovalQueue>,
     audit_logger: Arc<AuditLogger>,
     context_provider: Option<Arc<crate::rag::ContextProvider>>,
     timeout: Duration,
@@ -693,7 +685,7 @@ async fn execute_task_with_retry(
 
     // Emit task node started event
     let task_started_event = ai_agent_common::StatusEvent {
-        execution_id: conversation_id.to_string(),
+        conversation_id: conversation_id.to_string(),
         timestamp: chrono::Utc::now(),
         source: ai_agent_common::EventSource::Orchestrator,
         event: ai_agent_common::EventType::TaskNodeStarted {
@@ -703,7 +695,7 @@ async fn execute_task_with_retry(
             description: task.description.clone(),
         },
     };
-    
+
     if let Err(_) = status_sender.send(task_started_event).await {
         debug!("Failed to send task started event");
     }
@@ -716,7 +708,6 @@ async fn execute_task_with_retry(
         let result = tokio::time::timeout(timeout, execute_single_task(
             task.clone(),
             Arc::clone(&agent_pool),
-            approval_queue.clone(),
             audit_logger.clone(),
             context_provider.clone(),
             Arc::clone(&file_locks),
@@ -735,7 +726,7 @@ async fn execute_task_with_retry(
                     .await?;
 
                 // ADD HITL CHECK HERE:
-                if let (queue, logger) = (approval_queue.as_ref(), audit_logger.as_ref()) {
+                if let (logger) = (audit_logger.as_ref()) {
                     if task_result.success {
                         // Get agent for type information
                         if let Some(agent) = agent_pool.get_agent(&task.agent_id) {
@@ -751,35 +742,13 @@ async fn execute_task_with_retry(
                                 agent.agent_type(),
                                 Some(format!("Task {} completed", task.task_id)),
                             );
-
-                            if assessment.needs_hitl(queue.risk_threshold.clone()) {
-                                let req_id = Uuid::new_v4().to_string();
-
-                                queue.enqueue(ApprovalRequest {
-                                    request_id: req_id.clone(),
-                                    assessment: assessment.clone(),
-                                    decision: None,
-                                }).await;
-
-                                let audit_event = AuditEvent {
-                                    event_id: req_id.clone(),
-                                    timestamp: chrono::Utc::now(),
-                                    agent_id: task.agent_id.clone(),
-                                    task_id: task.task_id.clone(),
-                                    action: "TASK_COMPLETED_HITL".to_string(),
-                                    risk_level: format!("{:?}", assessment.risk_level),
-                                    decision: "Pending".to_string(),
-                                    metadata: std::collections::HashMap::new(),
-                                };
-                                crate::hitl::AuditLogger::log(audit_event);
-                            }
                         }
                     }
                 }
 
                 // Emit task node completed event
                 let task_completed_event = ai_agent_common::StatusEvent {
-                    execution_id: conversation_id.to_string(),
+                    conversation_id: conversation_id.to_string(),
                     timestamp: chrono::Utc::now(),
                     source: ai_agent_common::EventSource::Orchestrator,
                     event: ai_agent_common::EventType::TaskNodeCompleted {
@@ -789,7 +758,7 @@ async fn execute_task_with_retry(
                         success: true,
                     },
                 };
-                
+
                 if let Err(_) = status_sender.send(task_completed_event).await {
                     debug!("Failed to send task completed event");
                 }
@@ -835,7 +804,7 @@ async fn execute_task_with_retry(
 
     // Emit task node completed event for failed task
     let task_completed_event = ai_agent_common::StatusEvent {
-        execution_id: conversation_id.to_string(),
+        conversation_id: conversation_id.to_string(),
         timestamp: chrono::Utc::now(),
         source: ai_agent_common::EventSource::Orchestrator,
         event: ai_agent_common::EventType::TaskNodeCompleted {
@@ -845,7 +814,7 @@ async fn execute_task_with_retry(
             success: false,
         },
     };
-    
+
     if let Err(_) = status_sender.send(task_completed_event).await {
         debug!("Failed to send task completed event");
     }
diff --git a/crates/common/src/types.rs b/crates/common/src/types.rs
index f369206..e9d23b7 100644
--- a/crates/common/src/types.rs
+++ b/crates/common/src/types.rs
@@ -164,19 +164,19 @@ pub struct MessageMetadata {
     pub code_snippets: Vec<String>,
 }
 
-/// Real-time status event for WebSocket streaming  
+/// Real-time status event for WebSocket streaming
 #[derive(Debug, Clone, Serialize, Deserialize)]
 #[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
 pub struct StatusEvent {
     /// Unique identifier for this execution
-    pub execution_id: String,
-    
+    pub conversation_id: String,
+
     /// When this event occurred
     pub timestamp: DateTime<Utc>,
-    
+
     /// Source that generated this event
     pub source: EventSource,
-    
+
     /// The actual event data
     pub event: EventType,
 }
@@ -188,29 +188,29 @@ pub struct StatusEvent {
 pub enum EventSource {
     /// Event from the orchestrator
     Orchestrator,
-    
+
     /// Event from a specific agent
-    Agent { 
-        agent_id: String, 
+    Agent {
+        agent_id: String,
         agent_type: AgentType,
         task_id: Option<String>,
     },
-    
+
     /// Event from a tool being used by an agent
-    Tool { 
-        tool_name: String, 
-        agent_id: String 
+    Tool {
+        tool_name: String,
+        agent_id: String
     },
-    
+
     /// Event from workflow/DAG execution
-    Workflow { 
-        node_id: String, 
-        wave: usize 
+    Workflow {
+        node_id: String,
+        wave: usize
     },
-    
+
     /// Event from human-in-the-loop system
-    Hitl { 
-        request_id: String 
+    Hitl {
+        request_id: String
     },
 }
 
@@ -247,115 +247,123 @@ pub struct TaskInfo {
 #[serde(tag = "type", rename_all = "snake_case")]
 pub enum EventType {
     /// Execution has started
-    ExecutionStarted { 
-        query: String 
+    ExecutionStarted {
+        query: String
     },
-    
+
     /// Execution completed successfully
-    ExecutionCompleted { 
-        result: String 
+    ExecutionCompleted {
+        result: String
     },
-    
+
     /// Execution failed with an error
-    ExecutionFailed { 
-        error: String 
+    ExecutionFailed {
+        error: String
     },
-    
+
     /// An agent has started working
-    AgentStarted { 
-        context_size: usize 
+    AgentStarted {
+        context_size: usize
     },
-    
+
     /// Agent is thinking/processing (streaming thoughts)
-    AgentThinking { 
-        thought: String 
+    AgentThinking {
+        thought: String
     },
-    
+
     /// Agent has completed its task
-    AgentCompleted { 
-        result: String 
+    AgentCompleted {
+        result: String
     },
-    
+
     /// Agent failed to complete its task
-    AgentFailed { 
-        error: String 
+    AgentFailed {
+        error: String
     },
-    
+
     /// A tool has started executing
-    ToolStarted { 
-        args: serde_json::Value 
+    ToolStarted {
+        args: serde_json::Value
     },
-    
+
     /// Tool execution completed
-    ToolCompleted { 
-        result: serde_json::Value 
+    ToolCompleted {
+        result: serde_json::Value
     },
-    
+
     /// Tool execution failed
-    ToolFailed { 
-        error: String 
+    ToolFailed {
+        error: String
     },
-    
+
     /// Human-in-the-loop approval requested
-    HitlRequested { 
+    HitlRequested {
         task_description: String,
         risk_level: String,
     },
-    
+
+    /// Human-in-the-loop approval requested
+    HitlDecision{
+        id: String,
+        approved: bool,
+        modified_content: Option<String>,
+        reasoning: Option<String>,
+    },
+
     /// Human-in-the-loop decision received
-    HitlCompleted { 
+    HitlCompleted {
         approved: bool,
         reason: Option<String>,
     },
-    
+
     /// Workflow step started
-    WorkflowStepStarted { 
-        step_name: String 
+    WorkflowStepStarted {
+        step_name: String
     },
-    
+
     /// Workflow step completed
-    WorkflowStepCompleted { 
-        step_name: String 
+    WorkflowStepCompleted {
+        step_name: String
     },
-    
+
     /// Planning phase started
     PlanningStarted,
-    
+
     /// Planning phase completed
-    PlanningCompleted { 
+    PlanningCompleted {
         task_count: usize,
         reasoning: String,
     },
-    
+
     /// Execution plan ready with computed waves
     ExecutionPlanReady {
         plan: ExecutionPlan,
     },
-    
+
     /// Wave execution started
-    WaveStarted { 
+    WaveStarted {
         wave_index: usize,
         task_count: usize,
         task_ids: Vec<String>,
     },
-    
+
     /// Wave execution completed
-    WaveCompleted { 
+    WaveCompleted {
         wave_index: usize,
         success_count: usize,
         failure_count: usize,
     },
-    
+
     /// Task node started within a wave
-    TaskNodeStarted { 
+    TaskNodeStarted {
         task_id: String,
         agent_id: String,
         wave_index: usize,
         description: String,
     },
-    
+
     /// Task node completed within a wave
-    TaskNodeCompleted { 
+    TaskNodeCompleted {
         task_id: String,
         agent_id: String,
         wave_index: usize,
